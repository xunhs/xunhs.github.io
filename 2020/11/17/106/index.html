<!DOCTYPE html>
<html lang="en" dir="ltr">

<head prefix="og: http://ogp.me/ns#">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>博士论文阅读札记-3 – Ethan</title>
    




<script src="/js/enquire.min.dfb99dee1e029d51d6cfb672d847929890b1585402de17f5ed092edd72a688b4.js"></script>

<script defer src="/js/lazysizes.min.fb649fcae62177dfe63e67081ddceb830b5ce1f05a4184e9bbb7d87ac4b8f4e5.js"></script>

<script defer src="/js/helper/getParents.min.ccd45f158c1b17849307ba913a72beac239c410f2b6e648496a79842da84e55b.js"></script>

<script defer src="/js/helper/fadeinout.min.1d13d3e810c3940e80cbba6216a1c76fbf42b5431fc83537ea6997863802362b.js"></script>

<script defer src="/js/helper/closest.min.js"></script>
  
<script>
  "use strict";

  
  
  if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }

  
  if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
      'use strict';

      if (search instanceof RegExp) {
        throw TypeError('first argument must not be a RegExp');
      }
      if (start === undefined) { start = 0; }
      return this.indexOf(search, start) !== -1;
    };
  }

  
  Document.prototype.append = Element.prototype.append = function append() {
    this.appendChild(_mutation(arguments));
  };
  function _mutation(nodes) {
    if (!nodes.length) {
      throw new Error('DOM Exception 8');
    } else if (nodes.length === 1) {
      return typeof nodes[0] === 'string' ? document.createTextNode(nodes[0]) : nodes[0];
    } else {
      var
      fragment = document.createDocumentFragment(),
      length = nodes.length,
      index = -1,
      node;

      while (++index < length) {
        node = nodes[index];

        fragment.appendChild(typeof node === 'string' ? document.createTextNode(node) : node);
      }

      return fragment;
    }
  }

  
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    };
  }
  


  document.addEventListener('DOMContentLoaded', function () {
    
    var navCollapseBtn = document.querySelector('.navbar__burger');
    navCollapseBtn ? navCollapseBtn.addEventListener('click', function (e) {
      var navCollapse = document.querySelector('.navbarm__collapse');

      if (navCollapse) {
        var dataOpen = navCollapse.getAttribute('data-open');

        if (dataOpen === 'true') {
          navCollapse.setAttribute('data-open', 'false');
          navCollapse.style.maxHeight = 0;
          navCollapseBtn.classList.remove('is-active');
        } else {
          navCollapse.setAttribute('data-open', 'true');
          navCollapse.style.maxHeight = navCollapse.scrollHeight + "px";
          navCollapseBtn.classList.add('is-active');
        }
      }
    }) : null;
    


    
    var tables = document.querySelectorAll('.single__contents > table');
    for (let i = 0; i < tables.length; i++) {
      var table = tables[i];
      var wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';
      table.parentElement.replaceChild(wrapper, table);
      wrapper.appendChild(table);
    }
    


    
    var footNoteRefs = document.querySelectorAll('.footnote-ref');
    var footNoteBackRefs = document.querySelectorAll('.footnote-backref');

    footNoteRefs ? 
    footNoteRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function () {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;

    footNoteBackRefs ? 
    footNoteBackRefs.forEach(function(elem, idx) {
      elem.onmouseenter = function () {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      elem.onmouseleave = function () {
        if (!navbar.classList.contains('scrolling')) {
          setTimeout(function() {
            navbar.classList.add('scrolling');
          }, 100);
        }
      }

      elem.onclick = function () {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.remove('navbar--show');
          navbar.classList.remove('navbar--hide');
          navbar.classList.add('navbar--hide');
        }
      }
    }) : null;
    


    
    var summaryContainer = document.querySelector('.summary__container');
    var searchResult = document.querySelector('.search-result');
    var searchResultCloseBtn = document.querySelector('.search-result__close');
    searchResultCloseBtn ? searchResultCloseBtn.addEventListener('click', function (e) {
      searchResult.setAttribute('data-display', 'none');
      summaryContainer.setAttribute('data-display', 'block');
    }) : null;
    


    
    document.querySelectorAll('.tab') ? 
    document.querySelectorAll('.tab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var tabLinks = elem.querySelectorAll('.tab__link');
      var tabContents = elem.querySelectorAll('.tab__content');
      var ids = [];

      tabLinks && tabLinks.length > 0 ?
      tabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                tabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              tabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    document.querySelectorAll('.codetab') ? 
    document.querySelectorAll('.codetab').forEach(function(elem, idx) {
      var containerId = elem.getAttribute('id');
      var containerElem = elem;
      var codetabLinks = elem.querySelectorAll('.codetab__link');
      var codetabContents = elem.querySelectorAll('.codetab__content');
      var ids = [];

      codetabLinks && codetabLinks.length > 0 ?
      codetabLinks.forEach(function(link, index, self) {
        link.onclick = function(e) {
          for (var i = 0; i < self.length; i++) {
            if (index === parseInt(i, 10)) {
              if (!self[i].classList.contains('active')) {
                self[i].classList.add('active');
                codetabContents[i].style.display = 'block';
              }
            } else {
              self[i].classList.remove('active');
              codetabContents[i].style.display = 'none';
            }
          }
        }
      }) : null;
    }) : null;
    


    
    var gttBtn = document.getElementById("gtt");
    gttBtn.style.display = "none";
    gttBtn.addEventListener('click', function () {
      if (window.document.documentMode) {
        document.documentElement.scrollTop = 0;
      } else {
        scrollToTop(250);
      }
    });

    function scrollToTop(scrollDuration) {
      var scrollStep = -window.scrollY / (scrollDuration / 15);
      var scrollInterval = setInterval(function () {
        if (window.scrollY != 0) {
          window.scrollBy(0, scrollStep);
        }
        else clearInterval(scrollInterval);
      }, 15);
    }

    var scrollFunction = function () {
      if (document.body.scrollTop > 250 || document.documentElement.scrollTop > 250) {
        gttBtn.style.display = "block";
      } else {
        gttBtn.style.display = "none";
      }
    }
    


    
    var expandBtn = document.querySelectorAll('.expand__button');

    for (let i = 0; i < expandBtn.length; i++) {
      expandBtn[i].addEventListener("click", function () {
        var content = this.nextElementSibling;
        if (content.style.maxHeight) {
          content.style.maxHeight = null;
          this.querySelector('svg').classList.add('expand-icon__right');
          this.querySelector('svg').classList.remove('expand-icon__down');
        } else {
          content.style.maxHeight = content.scrollHeight + "px";
          this.querySelector('svg').classList.remove('expand-icon__right');
          this.querySelector('svg').classList.add('expand-icon__down');
        }
      });
    }
    


    
    var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
    var tocElem = document.querySelector('.toc');
    var tableOfContentsElem = tocElem ? tocElem.querySelector('#TableOfContents') : null;
    var toggleTocElem = document.getElementById('toggle-toc');
    var singleContentsElem = document.querySelector('.single__contents');
    var navbar = document.querySelector('.navbar');
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var expandContents = document.querySelectorAll('.expand__content');
    var boxContents = document.querySelectorAll('.box');
    var notAllowedTitleIds = null;

    
    var tocFolding = JSON.parse("true");
    
    var tocLevels = JSON.parse("[\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\"]");
    
    if (tocLevels) {
      tocLevels = tocLevels.toString();
    } else {
      tocLevels = "h1, h2, h3, h4, h5, h6";
    }

    
    singleContentsElem && singleContentsElem.querySelectorAll(".tab") ?
    singleContentsElem.querySelectorAll(".tab").forEach(function (elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    expandContents ? expandContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    boxContents ? boxContents.forEach(function(elem) {
      elem.querySelectorAll(tocLevels).forEach(function (element) {
        notAllowedTitleIds = Array.isArray(notAllowedTitleIds) ?
          notAllowedTitleIds.concat(element.getAttribute('id')) :
          [element.getAttribute('id')];
      });
    }) : null;

    
    window.onscroll = function () {
      scrollFunction();
      
      var st = window.pageYOffset || document.documentElement.scrollTop;
      if (st > lastScrollTop) { 
        if (st < 250) {
          gttBtn.style.display = "none";
        } else {
          gttBtn.style.display = "block";
        }

        if (st < 45) {
          return null;
        }

        if (navbar.classList.contains('scrolling')) {
          if (!navbar.classList.contains('navbar--hide')) {
            navbar.classList.add('navbar--hide');
          } else if (navbar.classList.contains('navbar--show')) {
            navbar.classList.remove('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }

              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }
              
              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox) {
              tocFlexbox.setAttribute('data-position', '');
              if (!tocFlexbox.classList.contains('hide')) {
                tocFlexbox.classList.add('hide');
              }
            }
            if (tocFlexboxOuter) {
              tocFlexboxOuter.setAttribute('data-position', '');
              if (!tocFlexboxOuter.classList.contains('hide')) {
                tocFlexboxOuter.classList.add('hide');
              }
            }
          }
        }
      } else { 
        if (st < 250) {
          gttBtn.style.display = "none";
        }

        if (navbar.classList.contains('scrolling')) {
          if (navbar.classList.contains('navbar--hide')) {
            navbar.classList.remove('navbar--hide');
          } else if (!navbar.classList.contains('navbar--show')) {
            navbar.classList.add('navbar--show');
          }
        }

        if (singleContentsElem) {
          if (singleContentsElem.querySelectorAll(tocLevels).length > 0) {
            singleContentsElem.querySelectorAll(tocLevels).forEach(function (elem) {
              if (toggleTocElem && !toggleTocElem.checked) {
                return null;
              }
              
              if (notAllowedTitleIds && notAllowedTitleIds.includes(elem.getAttribute('id'))) {
                return null;
              }

              if (document.documentElement.scrollTop >= elem.offsetTop) {
                if (tableOfContentsElem) {
                  var id = elem.getAttribute('id');
                  tocElem.querySelectorAll('a').forEach(function (elem) {
                    elem.classList.remove('active');
                  });
                  tocElem.querySelector('a[href="#' + id + '"]') ?
                    tocElem.querySelector('a[href="#' + id + '"]').classList.add('active') : null;

                  if (false === tocFolding) {
                    
                  } else {
                    tableOfContentsElem.querySelectorAll('ul') ?
                      tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
                        rootUl.querySelectorAll('li').forEach(function (liElem) {
                          liElem.querySelectorAll('ul').forEach(function (ulElem) {
                            ulElem.style.display = 'none';
                          });
                        });
                      }) : null;
                  }

                  var curElem = tableOfContentsElem.querySelector("[href='#" + id + "']");
                  if (curElem && curElem.nextElementSibling) {
                    curElem.nextElementSibling.style.display = 'block';
                  }
                  getParents(curElem, 'ul') ?
                    getParents(curElem, 'ul').forEach(function (elem) {
                      elem.style.display = 'block';
                    }) : null;
                }
              }
            });
          } else {
            if (tocFlexbox && !tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
            if (tocFlexboxOuter && !tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
          
        }

        if (tableOfContentsElem && document.documentElement.scrollTop < 250) {
          if (false === tocFolding) {

          } else {
            tableOfContentsElem.querySelector('ul') ?
              tableOfContentsElem.querySelector('ul').querySelectorAll('li').forEach(function (liElem) {
                liElem.querySelectorAll('ul').forEach(function (ulElem) {
                  ulElem.style.display = 'none';
                });
              }) : null;
          }
        }
      }
      lastScrollTop = st <= 0 ? 0 : st;
    };
  


  
    var localTheme = localStorage.getItem('theme');
    var rootEleme = document.getElementById('root');
    var selectThemeElem = document.querySelectorAll('.select-theme');
    var selectThemeItemElem = document.querySelectorAll('.select-theme__item');
    
    
    var skinDarkCode = JSON.parse("\"dark\"");
    
    var skinLightCode = JSON.parse("\"light\"");
    
    var skinHackerCode = JSON.parse("\"hacker\"");
    
    var skinSolarizedCode = JSON.parse("\"solarized\"");
    
    var skinKimbieCode = JSON.parse("\"kimbie\"");

    var setMetaColor = function(themeColor) {
      var metaMsapplicationTileColor = document.getElementsByName('msapplication-TileColor')[0];
      var metaThemeColor = document.getElementsByName('theme-color')[0];
      var metaMsapplicationNavbuttonColor = document.getElementsByName('msapplication-navbutton-color')[0];
      var metaAppleMobileWebAappStatusBarStyle = document.getElementsByName('apple-mobile-web-app-status-bar-style')[0];

      if (themeColor.includes('dark')) {
        metaMsapplicationTileColor.setAttribute('content', '#fcfcfa');
        metaThemeColor.setAttribute('content', '#403E41');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#403E41');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#403E41');
      } else if (themeColor.includes('light')) {
        metaMsapplicationTileColor.setAttribute('content', '#555');
        metaThemeColor.setAttribute('content', '#eee');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee');
      } else if (themeColor.includes('hacker')) {
        metaMsapplicationTileColor.setAttribute('content', '#e3cd26');
        metaThemeColor.setAttribute('content', '#252526');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#252526');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#252526');
      } else if (themeColor.includes('solarized')) {
        metaMsapplicationTileColor.setAttribute('content', '#d3af86');
        metaThemeColor.setAttribute('content', '#51412c');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#51412c');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#51412c');
      } else if (themeColor.includes('kimbie')) {
        metaMsapplicationTileColor.setAttribute('content', '#586e75');
        metaThemeColor.setAttribute('content', '#eee8d5');
        metaMsapplicationNavbuttonColor.setAttribute('content', '#eee8d5');
        metaAppleMobileWebAappStatusBarStyle.setAttribute('content', '#eee8d5');
      }
    }

    var parseSkinCode = function(themeText) {
      if (themeText === skinDarkCode) {
        return 'dark';
      } else if (themeText === skinLightCode) {
        return 'light';
      } else if (themeText === skinHackerCode) {
        return 'hacker';
      } else if (themeText === skinSolarizedCode) {
        return 'solarized';
      } else if (themeText === skinKimbieCode) {
        return 'kimbie';
      }
    }
    
    if (localTheme) {
      selectThemeItemElem ? 
      selectThemeItemElem.forEach(function (elem) {
        if (elem.text.trim() === localTheme) {
          elem.classList.add('is-active');
        } else {
          elem.classList.remove('is-active');
        }
      }) : null;

      setMetaColor(localTheme);
    } else {
      setMetaColor(rootEleme.className);
    }

    selectThemeItemElem ? 
    selectThemeItemElem.forEach(function (v, i) {
      v.addEventListener('click', function (e) {
        var selectedThemeVariant = parseSkinCode(e.target.text.trim());
        localStorage.setItem('theme', selectedThemeVariant);
        setMetaColor(selectedThemeVariant);

        rootEleme.removeAttribute('class');
        rootEleme.classList.add('theme__' + selectedThemeVariant);
        selectThemeElem.forEach(function(rootElem) {
          rootElem.querySelectorAll('a').forEach(function (elem) {
            if (elem.classList) {
              if (elem.text.trim() === selectedThemeVariant) {
                if (!elem.classList.contains('is-active')) {
                  elem.classList.add('is-active');
                }
              } else {
                if (elem.classList.contains('is-active')) {
                  elem.classList.remove('is-active');
                }
              }
            }
          });
        });

        if (window.mermaid) {
          if (selectedThemeVariant === "dark" || selectedThemeVariant === "hacker") {
            mermaid.initialize({ theme: 'dark' });
            location.reload();
          } else {
            mermaid.initialize({ theme: 'default' });
            location.reload();
          }
        }

        var utterances = document.getElementById('utterances');
        if (utterances) {
          utterances.querySelector('iframe').contentWindow.postMessage({
            type: 'set-theme',
            theme: selectedThemeVariant === "dark" || selectedThemeVariant === "hacker" ? 'photon-dark' : selectedThemeVariant === 'kimbie' ? 'github-dark-orange' : 'github-light',
          }, 'https://utteranc.es');
        }

        var twitterCards = document.querySelectorAll('.twitter-timeline');
        if (twitterCards) {
          window.postMessage({
            type: 'set-twitter-theme',
            theme: selectedThemeVariant === 'light' || selectedThemeVariant === 'solarized' ? 'light' : 'dark',
          });
        }
      });
    }) : null;
  


  
    
    var baseurl = JSON.parse("\"https://www.xunhs.cyou/\"");
    
    var permalink = JSON.parse("\"https://www.xunhs.cyou/2020/11/17/106/\"");
    
    var langprefix = JSON.parse("\"\"");
    var searchResults = null;
    var searchMenu = null;
    var searchText = null;
    
    
    var enableSearch = JSON.parse("false");
    
    var searchDistance = JSON.parse("100");
    
    var searchThreshold = JSON.parse("0.4");
    
    var searchContent = JSON.parse("true");
    
    var enableSearchHighlight = JSON.parse("true");
    
    var searchResultPosition = JSON.parse("\"main\"");
    
    var sectionType = JSON.parse("\"post\"");
    
    var kind = JSON.parse("\"page\"");
    
    var fuse = null;

    if (enableSearch) {
      (function initFuse() {
        var xhr = new XMLHttpRequest();
        if (sectionType === "publication" && kind !== "page") {
          xhr.open('GET', permalink + "index.json");
        } else {
          xhr.open('GET', baseurl + langprefix + "/index.json");
        }
        
        xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            fuse = new Fuse(JSON.parse(xhr.response.toString('utf-8')), {
              keys: sectionType.includes('publication') ? ['title', 'abstract'] : 
                searchContent ? ['title', 'description', 'content'] : ['title', 'description'],
              includeMatches: enableSearchHighlight,
              shouldSort: true, 
              threshold: searchThreshold ? searchThreshold : 0.4, 
              location: 0, 
              distance: searchDistance ? searchDistance : 100, 
              maxPatternLength: 32,
              minMatchCharLength: 1,
              isCaseSensitive: false, 
              findAllMatches: false, 
              useExtendedSearch: false, 
            });
            window.fuse = fuse;
          }
          else {
            console.error('[' + xhr.status + ']Error:', xhr.statusText);
          }
        };
        xhr.send();
      })();
    }

    function makeLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      
      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.permalink);

      var descDiv = document.createElement('div');
      descDiv.setAttribute('class', 'search-result__item--desc');
      if (obj.item.description) {
        descDiv.innerHTML = obj.item.description;
      } else if (obj.item.content) {
        descDiv.innerHTML = obj.item.content.substring(0, 225);
      }
      
      li.appendChild(a);
      li.appendChild(descDiv);
      ulElem.appendChild(li);
    }

    function makeHighlightLi(ulElem, obj) {
      var li = document.createElement('li');
      li.className = 'search-result__item';
      var descDiv = null;

      var a = document.createElement('a');
      a.innerHTML = obj.item.title;
      a.setAttribute('class', 'search-result__item--title');
      a.setAttribute('href', obj.item.uri);

      if (obj.matches && obj.matches.length) {
        for (var i = 0; i < obj.matches.length; i++) {
          if ('title' === obj.matches[i].key) {
            a = document.createElement('a');
            a.innerHTML = generateHighlightedText(obj.matches[i].value, obj.matches[i].indices);
            a.setAttribute('class', 'search-result__item--title');
            a.setAttribute('href', obj.item.uri);
          }
          
          if ('description' === obj.matches[i].key) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('class', 'search-result__item--desc');
            descDiv.innerHTML = generateHighlightedText(obj.item.description, obj.matches[i].indices);
          } else if ('content' === obj.matches[i].key) {
            if (!descDiv) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = generateHighlightedText(obj.item.content.substring(0, 150), obj.matches[i].indices);
            }
          } else {
            if (obj.item.description) {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.description;
            } else {
              descDiv = document.createElement('div');
              descDiv.setAttribute('class', 'search-result__item--desc');
              descDiv.innerHTML = obj.item.title.substring(0, 150);
            }
          }
        }

        li.appendChild(a);
        if (descDiv) {
          li.appendChild(descDiv);
        }
        if (li) {
          ulElem.appendChild(li);
        }
      }
    }

    function renderSearchResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');
      
      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', result.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.title;
          titleDiv.setAttribute('class', 'menu-item__title');

          var descDiv = document.createElement('div');
          descDiv.setAttribute('class', 'menu-item__desc');
          if (result.description) {
            descDiv.innerHTML = result.description;
          } else if (result.content) {
            descDiv.innerHTML = result.content.substring(0, 150);
          }

          li.appendChild(titleDiv);
          li.appendChild(descDiv);
          ul.appendChild(a);
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      
      searchMenu.appendChild(ul);
    }

    function renderSearchHighlightResultsSide(searchText, results) {
      searchResults = document.getElementById('search-results');
      searchMenu = document.getElementById('search-menu');
      searchResults.setAttribute('class', 'dropdown is-active');

      var ul = document.createElement('ul');
      ul.setAttribute('class', 'dropdown-content search-content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.setAttribute('class', 'dropdown-item');
          a.appendChild(li);

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'menu-item__title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'menu-item__desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'menu-item__desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var li = document.createElement('li');
        li.setAttribute('class', 'dropdown-item');
        li.innerText = 'No results found';
        ul.appendChild(li);
      }

      while (searchMenu.hasChildNodes()) {
        searchMenu.removeChild(
          searchMenu.lastChild
        );
      }
      searchMenu.appendChild(ul);
    }

    function renderSearchResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var content = document.createElement('div');
      content.setAttribute('class', 'mobile-search__content');

      if (results.length > 0) {
        results.forEach(function (result) {
          var item = document.createElement('a');
          item.setAttribute('href', result.uri);
          item.innerHTML = '<div class="mobile-search__item"><div class="mobile-search__item--title">📄 ' + result.title + '</div><div class="mobile-search__item--desc">' + (result.description ? result.description : result.content) + '</div></div>';
          content.appendChild(item);
        });
      } else {
        var item = document.createElement('span');
        content.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(content);      
    }

    function renderSearchHighlightResultsMobile(searchText, results) {
      searchResults = document.getElementById('search-mobile-results');

      var ul = document.createElement('div');
      ul.setAttribute('class', 'mobile-search__content');

      if (results.length) {
        results.forEach(function (result) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          var descDiv = null;

          a.setAttribute('href', result.item.uri);
          a.appendChild(li);
          li.setAttribute('class', 'mobile-search__item');

          var titleDiv = document.createElement('div');
          titleDiv.innerHTML = result.item.title;
          titleDiv.setAttribute('class', 'mobile-search__item--title');
          
          if (result.matches && result.matches.length) {
            for (var i = 0; i < result.matches.length; i++) {
              if ('title' === result.matches[i].key) {
                titleDiv.innerHTML = generateHighlightedText(result.matches[i].value, result.matches[i].indices);
              }

              if ('description' === result.matches[i].key) {
                descDiv = document.createElement('div');
                descDiv.setAttribute('class', 'mobile-search__item--desc');
                descDiv.innerHTML = generateHighlightedText(result.item.description, result.matches[i].indices);
              } else if ('content' === result.matches[i].key) {
                if (!descDiv) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = generateHighlightedText(result.item.content.substring(0, 150), result.matches[i].indices);
                }
              } else {
                if (result.item.description) {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.description;
                } else {
                  descDiv = document.createElement('div');
                  descDiv.setAttribute('class', 'mobile-search__item--desc');
                  descDiv.innerHTML = result.item.content.substring(0, 150);
                }
              }
            }
            
            li.appendChild(titleDiv);
            if (descDiv) {
              li.appendChild(descDiv);
            }
            ul.appendChild(a);
          }
        });
      } else {
        var item = document.createElement('span');
        ul.appendChild(item);
      }

      let wrap = document.getElementById('search-mobile-results');
      while (wrap.firstChild) {
        wrap.removeChild(wrap.firstChild)
      }
      searchResults.appendChild(ul);
    }

    function generateHighlightedText(text, regions) {
      if (!regions) {
        return text;
      }

      var content = '', nextUnhighlightedRegionStartingIndex = 0;

      regions.forEach(function(region) {
        if (region[0] === region[1]) {
          return null;
        }
        
        content += '' +
          text.substring(nextUnhighlightedRegionStartingIndex, region[0]) +
          '<span class="search__highlight">' +
            text.substring(region[0], region[1] + 1) +
          '</span>' +
        '';
        nextUnhighlightedRegionStartingIndex = region[1] + 1;
      });

      content += text.substring(nextUnhighlightedRegionStartingIndex);

      return content;
    };

    var searchElem = document.getElementById('search');
    var searchMobile = document.getElementById('search-mobile');
    var searchResultsContainer = document.getElementById('search-results');

    searchElem ?
    searchElem.addEventListener('input', function(e) {
      if (!e.target.value | window.innerWidth < 770) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      
      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }
        
        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function(item) {
          item.addEventListener('mousedown', function(e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    searchElem ? 
    searchElem.addEventListener('blur', function() {
      if (window.innerWidth < 770) {
        return null;
      }
      searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
    }) : null;

    searchElem ? 
    searchElem.addEventListener('click', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }
      if (!e.target.value) {
        searchResultsContainer ? searchResultsContainer.setAttribute('class', 'dropdown') : null;
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);

      if (searchResultPosition === "main") {
        if (enableSearchHighlight) {
          renderSearchHighlightResultsMain(searchText, results);
        } else {
          renderSearchResultsMain(searchText, results);
        }
      } else{
        if (enableSearchHighlight) {
          renderSearchHighlightResultsSide(searchText, results);
        } else {
          renderSearchResultsSide(searchText, results);
        }

        var dropdownItems = searchResultsContainer.querySelectorAll('.dropdown-item');
        dropdownItems ? dropdownItems.forEach(function (item) {
          item.addEventListener('mousedown', function (e) {
            e.target.click();
          });
        }) : null;
      }
    }) : null;

    var searchMenuElem = document.getElementById("search-menu");
    var activeItem = document.querySelector('#search-menu .dropdown-item.is-active');
    var activeIndex = null;
    var items = null;
    var searchContainerMaxHeight = 350;

    searchElem ? 
    searchElem.addEventListener('keydown', function(e) {
      if (window.innerWidth < 770) {
        return null;
      }

      if (e.key === 'Escape') {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      }

      var items = document.querySelectorAll('#search-menu .dropdown-item');
      var keyCode = e.which || e.keyCode;

      if (!items || !items.length) {
        return null;
      }
      
      if (e.key === 'ArrowDown' || keyCode === 40) {
        if (activeIndex === null) {
          activeIndex = 0;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === items.length - 1 ? 0 : activeIndex + 1;
        }
        items[activeIndex].classList.add('is-active');

        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel > 0) {
          document.querySelector(".search-content").scrollTop += items[activeIndex].getBoundingClientRect().height;
        } else if (activeIndex === 0) {
          document.querySelector(".search-content").scrollTop = 0;
        }
      } else if (e.key === 'ArrowUp' || keyCode === 38) {
        if (activeIndex === null) {
          activeIndex = items.length - 1;
          items[activeIndex].classList.remove('is-active');
        } else {
          items[activeIndex].classList.remove('is-active');
          activeIndex = activeIndex === 0 ? items.length - 1 : activeIndex - 1;
        }
        items[activeIndex].classList.add('is-active');
        
        let overflowedPixel = items[activeIndex].offsetTop + items[activeIndex].clientHeight - searchContainerMaxHeight;
        if (overflowedPixel < 0) {
          document.querySelector(".search-content").scrollTop -= items[activeIndex].getBoundingClientRect().height;
        } else {
          document.querySelector(".search-content").scrollTop = overflowedPixel + items[activeIndex].getBoundingClientRect().height;
        }
      } else if (e.key === 'Enter' || keyCode === 13) {
        if (items[activeIndex] && items[activeIndex].getAttribute('href')) {
          location.href = items[activeIndex].getAttribute('href');
        }
      } else if (e.key === 'Escape' || keyCode === 27) {
        e.target.value = null;
        if (searchResults) {
          searchResults.classList.remove('is-active');
        }
      }
    }) : null;

    searchMobile ? 
    searchMobile.addEventListener('input', function(e) {
      if (!e.target.value) {
        let wrap = document.getElementById('search-mobile-results');
        while (wrap.firstChild) {
          wrap.removeChild(wrap.firstChild);
        }
        return null;
      }

      searchText = e.target.value;
      var results = fuse.search(e.target.value);
      renderSearchResultsMobile(searchText, results);
      if (enableSearchHighlight) {
        renderSearchHighlightResultsMobile(searchText, results);
      } else {
        renderSearchResultsMobile(searchText, results);
      }
    }) : null;
  


  
    var mobileSearchInputElem = document.querySelector('#search-mobile');
    var mobileSearchClassElem = document.querySelector('.mobile-search');
    var mobileSearchBtnElems = document.querySelectorAll('.navbar-search');
    var mobileSearchCloseBtnElem = document.querySelector('#search-mobile-close');
    var mobileSearchContainer = document.querySelector('#search-mobile-container');
    var mobileSearchResultsElem = document.querySelector('#search-mobile-results');
    var htmlElem = document.querySelector('html');

    if (mobileSearchClassElem) {
      mobileSearchClassElem.style.display = 'none';
    }

    mobileSearchBtnElems ? 
    mobileSearchBtnElems.forEach(function (elem, idx) {
      elem.addEventListener('click', function () {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'block';
        }

        if (mobileSearchInputElem) {
          mobileSearchInputElem.focus();
        }

        if (htmlElem) {
          htmlElem.style.overflowY = 'hidden';
        }
      });
    }) : null;

    mobileSearchCloseBtnElem ? 
    mobileSearchCloseBtnElem.addEventListener('click', function() {
      if (mobileSearchContainer) {
        mobileSearchContainer.style.display = 'none';
      }

      if (mobileSearchInputElem) {
        mobileSearchInputElem.value = '';
      }
      
      if (mobileSearchResultsElem) {
        while (mobileSearchResultsElem.firstChild) {
          mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
        }
      }

      if (htmlElem) {
        htmlElem.style.overflowY = 'visible';
      }
    }) : null;

    mobileSearchInputElem ?
    mobileSearchInputElem.addEventListener('keydown', function(e) {
      var keyCode = e.which || e.keyCode;
      if (e.key === 'Escape' || keyCode === 27) {
        if (mobileSearchContainer) {
          mobileSearchContainer.style.display = 'none';
        }
        
        if (mobileSearchInputElem) {
          mobileSearchInputElem.value = '';
        }

        if (mobileSearchResultsElem) {
          while (mobileSearchResultsElem.firstChild) {
            mobileSearchResultsElem.removeChild(mobileSearchResultsElem.firstChild);
          }
        }
        if (htmlElem) {
          htmlElem.style.overflowY = 'visible';
        }
      }
    }) : null;
  


  
    function renderSearchResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');
      
      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }

    function renderSearchHighlightResultsMain(searchText, results) {
      var searchBody = document.querySelector('.search-result__body');
      var originUl = searchBody.querySelector('ul');
      var ul = document.createElement('ul');

      if (!searchText) {
        searchResult ? searchResult.setAttribute('data-display', 'none') : null;
        summaryContainer ? summaryContainer.setAttribute('data-display', 'block') : null;
      } else if (results) {
        if (results && results.length) {
          results.forEach(function (result) {
            makeHighlightLi(ul, result);
          });

          searchResult ? searchResult.setAttribute('data-display', 'block') : null;
          summaryContainer ? summaryContainer.setAttribute('data-display', 'none') : null;
        }
      }

      originUl.parentNode.replaceChild(ul, originUl);
    }
  
  });
</script>    
    


<link rel="stylesheet" href="/css/main.min.css">


    
<meta name="description" content="曾经沧海难为水." />


<meta name="keywords" content="博士论文,阅读笔记">

<meta name="created" content="2020-11-17T09:32:16&#43;0000">
<meta name="modified" content="2020-11-17T09:32:16&#43;0000">
<meta property="article:published_time" content="2020-11-17T09:32:16&#43;0000">

<meta name="author" content="Ethan">
<meta property="article:author" content="https://www.xunhs.cyou/2020/11/17/106/@Ethan">


<meta property="og:site_name" content="Ethan">
<meta property="og:title" content="博士论文阅读札记-3">
<meta property="og:url" content="https://www.xunhs.cyou/2020/11/17/106/">
<meta property="og:type" content="article">
<meta property="og:description" content="曾经沧海难为水.">

<meta name="generator" content="Hugo 0.83.1" />
<meta name="msapplication-TileColor" content="#fff">

<meta name="theme-color" content="#fff">

<meta name="msapplication-navbutton-color" content="#fff">

<meta name="apple-mobile-web-app-status-bar-style" content="#fff">

<link rel="canonical" href="https://www.xunhs.cyou/2020/11/17/106/">

<link rel="manifest" href="/manifest.json">

  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/favicon.png" sizes="any" type="image/png" />
  


    <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "headline": "博士论文阅读札记-3",
    "datePublished": "2020-11-17T09:32:16Z",
    "dateModified": "2020-11-17T09:32:16Z",
    "url" : "https://www.xunhs.cyou/2020/11/17/106/",
    "description": "\u003cblockquote\u003e \u003cp\u003e续 博士论文阅读札记-2\u003c/p\u003e \u003c/blockquote\u003e",
    "keywords": ["博士论文","阅读笔记"],
    "author": {
      "@type": "Person",
      "name": "Ethan"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://www.xunhs.cyou/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Ethan",
      "url": "https://www.xunhs.cyou/"
    }
  }
</script>

    
  
  







    
</head>

<body id="root" class="theme__dark">
    <script>
        var localTheme = localStorage.getItem('theme');
        if (localTheme) {
            document.getElementById('root').className = 'theme__' + localTheme;
        }
    </script>
    <div id="container">
        





        <div class="wrapper" data-type="post" data-kind="page">
            <nav class="navbar scrolling" role="navigation" aria-label="main navigation" data-dir="ltr">
  <div class="navbar__brand">
    
    <a href="/" title="Home" rel="home" class="navbar__logo-link">
      <img src="/logo.png" alt="Home" class="navbar__logo">
    </a>
    
    
      <a href="/" title="Home" rel="home" class="navbar__title-link">
        <h6 class="navbar__title">Ethan</h6>
      </a>
    
  </div>

  
<div class="theme theme-mobile" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" style="position: absolute; top: 0;" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>



<a role="button" class="navbar__burger" aria-label="menu" aria-expanded="false"
  data-ani="true">
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
  <span aria-hidden="true"></span>
</a>
<div class="navbarm__collapse" data-open="false">
  <ul dir="ltr">
    
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/archive">archive</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/posts">posts</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/moments">moments</a>
        </li>
      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/">
            cloud
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z"/></svg>
          </a>
        </li>

        
          <li class="navbarm__menu--item navbarm__menu--subitem">
            <a href="https://cloudreve.xunhs.cyou">cloudreve</a>
          </li>
        
          <li class="navbarm__menu--item navbarm__menu--subitem">
            <a href="https://one.xunhs.cyou">olaindex</a>
          </li>
        
          <li class="navbarm__menu--item navbarm__menu--subitem">
            <a href="https://tianyi.xunhs.cyou">tianyi</a>
          </li>
        

      
      
    
      
      
      
      

      
        <li class="navbarm__menu--item ">
          <a href="/about">about</a>
        </li>
      
      
    

    
      <li class="navbarm__menu--item ">
        <a href="/categories" class="navbarm__menu--term" data-index="0">
          Categories
        </a>
      </li>
    
      <li class="navbarm__menu--item ">
        <a href="/series" class="navbarm__menu--term" data-index="1">
          Series
        </a>
      </li>
    
  </ul>
</div>
  <div class="navbar__menu">
  
  
  
<div class="theme" data-ani="true">
  <div class="dropdown">
    <button class="dropdown-trigger navbar__slide-down" aria-label="Select Theme Button" data-ani="true">
      <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24"><path fill="none" d="M24 0H0v24h24V0z"/><path fill="currentColor" d="M6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58s4.1-.78 5.66-2.34c3.12-3.12 3.12-8.19 0-11.31l-4.95-4.95c-.39-.39-1.02-.39-1.41 0L6.34 7.93zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"/></svg>      
    </button>
    <div class="dropdown-content select-theme">
      
        
        <a href="#" class="dropdown-item select-theme__item is-active">
          dark
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          light
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          hacker
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          solarized
        </a>
        
        <a href="#" class="dropdown-item select-theme__item ">
          kimbie
        </a>
        
      
    </div>
  </div>
</div>

  
  
  
  
  
  
  
  <a href="/archive" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">archive</a>
  
  
  
  
  
  
  
  <a href="/posts" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">posts</a>
  
  
  
  
  
  
  
  <a href="/moments" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">moments</a>
  
  
  
  
  
  
  
  <div class="navbar__dropdown navbar__slide-down" data-ani="true">
    <a href="/" class="navbar__menu-item "
      dir="ltr">
      cloud
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 9.29L12 13.17l3.88-3.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-4.59 4.59c-.39.39-1.02.39-1.41 0L6.7 10.7c-.39-.39-.39-1.02 0-1.41.39-.38 1.03-.39 1.42 0z"/></svg>
    </a>
    <div class="navbar__dropdown--content">
      
      <a href="https://cloudreve.xunhs.cyou" class="navbar__dropdown--item" dir="ltr">cloudreve</a>
      
      <a href="https://one.xunhs.cyou" class="navbar__dropdown--item" dir="ltr">olaindex</a>
      
      <a href="https://tianyi.xunhs.cyou" class="navbar__dropdown--item" dir="ltr">tianyi</a>
      
    </div>
  </div>
  
  
  
  
  
  
  
  <a href="/about" class="navbar__menu-item navbar__slide-down " dir="ltr" data-ani="true">about</a>
  
  
</div>
</nav>
            
            
<main class="single__main main">
  
    <nav class="breadcrumb hide" aria-label="breadcrumbs">
  <script>document.querySelector('.breadcrumb').classList.remove('hide')</script>
  <ol>
    
  
  
  
  
  
  <li >
    
      <a href="https://www.xunhs.cyou/" class="capitalize">Ethan</a>
    
  </li>
  
  
  <li >
    
      <a href="https://www.xunhs.cyou/posts/" class="capitalize">Posts</a>
    
  </li>
  
  
  <li  class="is-active" >
    
      <span>博士论文阅读札记-3</span>
    
  </li>
  
  </ol>
  
</nav>
  
  
  <div class="single ">
    <div class="single__nojs">This page looks best with JavaScript enabled</div>
    <script>document.querySelector('.single').classList.remove('hide'); document.querySelector('.single__nojs').classList.add('hide');</script>
    <h2 class="single__title" data-ani="true">博士论文阅读札记-3</h2>
    <h3 class="single__subtitle"></h3>
    <div class="single__meta">
      
<div class="single__infos">
  <time class="single__info" title="Written At">📅&nbsp;Nov 17, 2020 </time>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="Reading Time"> ☕&nbsp;48&nbsp;min read </span>
  
  &nbsp;&middot;&nbsp; <span class="single__info" title="WRITTEN BY">✍️&nbsp;Ethan</span>
  
  <span class="single__info">
    
  </span>
</div>

      
<ul class="single__tags caption">
  
  🏷️
  

  <li><a href="https://www.xunhs.cyou/tags/%E5%8D%9A%E5%A3%AB%E8%AE%BA%E6%96%87/" class="single__tag" title="博士论文">#博士论文</a></li>

  <li><a href="https://www.xunhs.cyou/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="single__tag" title="阅读笔记">#阅读笔记</a></li>

</ul>

    </div>
    <article class="single__contents" data-dir="ltr" data-ani="true">
      
      <blockquote>
<p>续 博士论文阅读札记-2</p>
</blockquote>
<hr />
<ul>
<li><input disabled="" type="checkbox" /> 区域尺度城市土地遥感监测关键技术研究</li>
<li><input checked="" disabled="" type="checkbox" /> 轨迹数据挖掘关键技术研究</li>
<li><input disabled="" type="checkbox" /> 基于地理场景的城市功能区建模与分析方法研究</li>
</ul>
<hr />
<h1 id="区域尺度城市土地遥感监测关键技术研究">区域尺度城市土地遥感监测关键技术研究</h1>
<p>王润-2018-中国地质大学（武汉）</p>
<h2 id="摘要">摘要</h2>
<ul>
<li>背景：
<ul>
<li>城市➡️城市化➡️城市建设用地不断增加 ➡️ <strong>城市的扩张</strong></li>
<li>造成问题：
<ul>
<li>改变局部地区的土地覆被构成</li>
<li>影响区域乃至全球的生态系统</li>
</ul>
</li>
<li>意义：我国的<u>城市化率</u>还在持续增长中，及时、准确地掌握<u>城市土地利用变化</u>能够防范与遏制城市盲目扩张，为宏观决策制定提供科学依据</li>
</ul>
</li>
<li>城市土地监测及其相关研究
<ul>
<li>逐渐从针对单个城市的分析<strong>转向</strong>区域和更宏观尺度的探讨</li>
<li>利用<strong>遥感技术</strong>开展区域城市土地监测</li>
<li>国内外学者取得了丰硕的研究成果，但在区域尺度下仍存在一些问题
<ol>
<li>在<strong>数据方面</strong>，低空间分辨率遥感数据中<u>存在大量的混合像元</u>，城市像元的“同物异谱”和“异物同谱”现象易导致城市土地的低估或高估情况 ➡️ 如何在区域尺度下发挥各种遥感数据的优势还需进一步研究。</li>
<li>在<strong>方法方面</strong>，区域尺度的城市制图是典型的<u>不平衡分类问题</u>，非城市像元数量远大于城市像元数量。➡️ 还需从方法入手，发展<u>针对于特定类别的</u>城市提取方法，在<u>少量样本</u>的前提下获取准确的城市区域。</li>
</ol>
</li>
</ul>
</li>
<li>针对现有区域尺度城市土地遥感监测中存在的问题，本文:
<ul>
<li>研究对象：区域尺度下的“城市”</li>
<li>数据支撑：三类常用的区域尺度城市土地遥感监测数据（<u>夜间灯光影像</u> DMSP/OLS NTL 与 NPP-VIIRS DNB，<u>MODIS 数据产品</u> MOD09A1 与MOD13A1，以及包含城市类别的<u>全球土地覆被数据集</u> MCD12Q1 与 GlobeLand30）</li>
<li>针对单目标的方法：即基于<u>知识驱动</u>的指数模型法与基于<u>数据驱动</u>的一类分类法</li>
</ul>
</li>
<li>主要研究内容与结论：
<ol>
<li>在数据方面，本文分析了三种遥感数据的<strong>数据结构与数据质量</strong>，并给出了原始数据的<strong>处理策略</strong>
<ul>
<li>夜间灯光数据 NPP-VIIRS DNB 去噪与极大值过滤，MOD09A1 影像筛选与质量控制，MOD13A1  NDVI 最大值合成以及基于 GLC30-2010 人造地表类型的城市区域提取</li>
<li>结果表明：数据的结合准确性高；贡献程度更高；更好的微光探测能力</li>
</ul>
</li>
<li>基于<strong>知识驱动</strong>的指数模型法
<ul>
<li>居民地指数 LHSI</li>
<li>实验结果表明：更有效；准确性高；更丰富的城市内部细节信息</li>
</ul>
</li>
<li>基于<strong>数据驱动</strong>的一类分类法
<ul>
<li>一类分类方法 PUL</li>
<li>实验结果表明：准确度更高；更清晰的城市边界；鲁棒性</li>
</ul>
</li>
<li>2012 年中国大陆城市<strong>区域专题图</strong>
<ul>
<li>本文结果与地表情况更接近，准确性更高。</li>
<li>验证试验表明：在像素级别；在城市级别上</li>
</ul>
</li>
</ol>
</li>
<li>技术路线：<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201110205222.png" alt="" /></li>
</ul>
<h1 id="轨迹数据挖掘关键技术研究">轨迹数据挖掘关键技术研究</h1>
<p>吴睿智-2020-电子科技大学</p>
<h2 id="摘要-1">摘要</h2>
<ul>
<li>背景：<u>定位技术与位置社交网络</u>高速发展➡️<u>轨迹数据</u>呈爆炸式增长</li>
<li>意义：
<ol>
<li>移动对象的时空特征和移动行为信息</li>
<li>挖掘海量轨迹数据背后所蕴藏的丰富信息，既有<strong>理论研究价值</strong>也是<strong>紧迫的现实需求</strong></li>
<li>未来城市服务的主要研究方向，广泛应用</li>
</ol>
</li>
<li>轨迹数据挖掘在实际应用场景中仍面临一些问题
<ol>
<li>由于<u>轨迹数据语义缺失</u>，人们无法<strong>理解轨迹数据中隐含的语义特征</strong></li>
<li><u>轨迹点序列式的表征</u>方式无法适应于广泛的数据挖掘模型</li>
<li>现有的位置预测模型的<u>预测精度较低</u></li>
</ol>
</li>
<li>关键技术: 轨迹语义推断、轨迹表征学习、位置预测性能提升</li>
<li>主要内容+研究成果
<ol>
<li>针对<strong>轨迹语义缺失</strong>的问题，论文提出一种<strong>基于图卷积神经网络的位置语义推断模型</strong> (SI­-GCN)
<ul>
<li>利用网络表征学习算法和变分自编码器<u>分别学习位置的空间向量表征和时间向量表征</u>，构成<strong>位置的时空特征</strong></li>
<li>用户-位置访问二部图</li>
<li>图卷积神经网络学习</li>
<li>引入自注意力机制</li>
<li>结果表明：SI-GCN 的语义推断性能优于现有方法</li>
</ul>
</li>
<li>针对<strong>轨迹表征困难</strong>的问题，论文提出<strong>融合时空结构的轨迹数据表征学习算法</strong> (STAR)
<ul>
<li><strong>传统轨迹点序列表征</strong>方式割裂<strong>轨迹数据的时空耦合关系</strong>（❓），且不适应于广泛的数据挖掘模型</li>
<li>STAR <strong>建立统一框架学习</strong>（❓）轨迹中的空间和时间信息：地理上下文、轨迹上下文、语义上下文</li>
<li>利用<u>自适应霍克斯过程</u>建模用户出行时间信息（下一个访问位置和时间）</li>
<li>结果表明：STAR 在相似性检索、相似度度量、异常检测等数据挖掘任务优于现有方法</li>
</ul>
</li>
<li>针对个人出行数据<strong>随机性高、数据稀疏</strong>，导致现有<strong>位置预测模型精度较低</strong>的问题，论文提出<strong>基于偏好社交互动的位置预测算法</strong> (PSI)
<ul>
<li>群组出行模式</li>
<li>度量<u>用户轨迹相似度</u>构建用户群组</li>
<li>利用<u>关联规则挖掘算法</u>提取群组出行模式</li>
<li>建立个人偏好模型</li>
<li>通过<strong>岭回归学习</strong>个人偏好与群组出行模式对位置预测的贡献，预测用户出行位置</li>
<li>结果表明：与现有方法相比，位置预测性能优于现有预测算法</li>
</ul>
</li>
<li>针对用户签到行为的成因与动态机制<strong>缺乏深入研究的问题</strong>（👍），论文提出<strong>地理感知的用户行为动态模型</strong> (DGPS)
<ul>
<li>用户签到行为的动态机制（❓）</li>
<li>地理感知的位置特征（包括语义特征、潜在特征和动态特征）➡️ 学习<strong>用户个人偏好</strong></li>
<li>用户行为的强度函数</li>
<li>同时预测用户签到活动的位置与时间</li>
<li>结果表明：多个真实数据集上的实验结果表明 DGPS 预测性能优于现有方法</li>
</ul>
</li>
</ol>
</li>
<li>技术路线：<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201110205501.png" alt="" /></li>
</ul>
<h2 id="绪论">绪论</h2>
<h3 id="研究工作的背景与意义">研究工作的背景与意义</h3>
<ul>
<li>轨迹数据
<ol>
<li>GPS 轨迹数据
<ol>
<li>交通工具产生的轨迹，飞机、船舶、汽车上配备 GPS 设备</li>
<li>人类活动轨迹，智能手环、穿戴设备、智能手机的健康应用程序会记录用户的位置信息</li>
<li>自然界其他移动对象轨迹，如动物迁徙数据，飓风的移动数据</li>
</ol>
</li>
<li>签到 (check­in) 轨迹数据
<ol>
<li>基于位置服务的社交网络 (Location­Based Social Networks, LBSNs) 应用如 Foursquare、Gowalla、微博、微信等移动社交网络</li>
<li>智能设备到达不同位置时接入网络设备的位置信息（Wi­Fi，通信基站）</li>
</ol>
</li>
<li>这些<strong>移动对象由于空间位置移动而产生的移动数据，按照时间先后顺序构成的数据</strong>都属于轨迹数据</li>
</ol>
</li>
<li>轨迹数据挖掘意义
<ol>
<li>轨迹数据挖掘是数据挖掘的一个新兴分支，拓展了传统数据挖掘的研究方法和应用领域，成为当前研究热点
<ul>
<li>KDD、ICDE、ICDM 等国际知名学术会议</li>
<li>TKDE、TKDD、TIST 等国际学术杂志</li>
</ul>
</li>
<li>研究轨迹数据挖掘相关技术也具有广泛的应用价值
<ul>
<li>对人类轨迹数据的挖掘：更好的理解人类行为动力学特征；有利于探索理解人类社会活动特性</li>
<li>对城市交通的轨迹数据的挖掘</li>
<li>对船舶、飞机的轨迹数据挖掘</li>
<li>从动物迁徙数据分析动物迁徙规律</li>
<li>从飓风的移动数据分析出飓风的形成位置和移动规律，提前预警气象灾害</li>
</ul>
</li>
<li>城市计算、智慧城市等<strong>城市未来发展研究</strong>，核心均是群体感知与移动位置的感知计算</li>
</ol>
</li>
<li>现有工作：轨迹预处理、轨迹相似度度量、轨迹检索、模式挖掘、轨迹聚类和异常检测等</li>
<li>存在一些潜在问题：
<ol>
<li>轨迹语义缺失</li>
<li>轨迹表征困难</li>
<li>位置预测精度低</li>
</ol>
</li>
<li>总结：轨迹数据挖掘有深刻的理论研究价值和广泛的应用前景，论文围绕上述三个问题，开展理论算法与关键技术研究。</li>
</ul>
<h2 id="轨迹数据挖掘相关理论基础">轨迹数据挖掘相关理论基础</h2>
<h3 id="轨迹数据语义研究相关理论">轨迹数据语义研究相关理论</h3>
<h4 id="轨迹数据中的语义信息按语义层次">轨迹数据中的语义信息（按语义层次）</h4>
<ol>
<li>
<p>简单语义信息</p>
<ul>
<li>轨迹的起点、终点、停留点、兴趣点都属于轨迹中的特殊位置信息，蕴含着简单的语义信息</li>
<li>简单语义信息能够反映用户轨迹中用户出行的空间特征或运动状态，但简单语义信息不含有任何语言类的语义解释，<strong>缺乏更深层次的语义理解</strong></li>
</ul>
</li>
<li>
<p>地理语义信息</p>
<ul>
<li>利用地标建筑物标注、地图匹配算法、位置语义推断算法赋予轨迹数据高层次的语义解释信息</li>
<li><strong>签到位置</strong>属于不同语义类别，医院、酒吧、公司、商店等</li>
<li>地图匹配算法将轨迹数据映射至城市路网中，<strong>利用路网的辅助语义信息</strong>，如<u>十字路口、道路信息</u>刻画用户在城市中的出行行为。</li>
<li>常见的地理语义信息还包括地理数据（植被、河流、行政划分等）、地标建筑物、可获取兴趣点（大众点评等网站提供）等</li>
<li>地理语义信息含有人类活动中的可理解语义信息，不仅能够反映用户运动状态，还包含用户出行含义，从哪里来、到哪去、活动目的等。</li>
</ul>
</li>
<li>
<p>描述性语义信息</p>
<ul>
<li>
<p>签到活动时分享自己的感受，发布图片或视频等多媒体信息</p>
</li>
<li>
<p>描述性语义信息表达了用户在签到位置所做的<strong>具体事情</strong>，甚至包括更高层的用户情绪，政治倾向等</p>
</li>
<li>
<p>通过文本或多媒体信息推断位置语义、为位置添加特定的标签（如“文青聚集地”的标签），利用照片分享或短视频传播等社交传播方式加速地理位置影响力的传播</p>
</li>
</ul>
</li>
</ol>
<h4 id="当前轨迹数据语义研究">当前轨迹数据语义研究</h4>
<ol>
<li>轨迹语义推断
<ul>
<li>粗轨迹信息提取语义 ➡️  分析用户在地理空间中的运动状态</li>
<li>利用地图匹配或地理信息推断语义，通过增加额外的地理空间信息，如路网或地标建筑等，采用相关算法匹配轨迹，赋予轨迹数据可理解的语义信息。</li>
<li>语义补全</li>
</ul>
</li>
<li>轨迹语义模式挖掘：利用轨迹中的语义特征执行数据挖掘任务，如轨迹语义压缩、轨迹语义分段、生活模式挖掘等</li>
<li>基于语义分析的事件检测</li>
</ol>
<h3 id="轨迹表征研究相关理论">轨迹表征研究相关理论</h3>
<ol>
<li>
<p>第一段：绪言</p>
<ul>
<li>
<p>轨迹是轨迹点按照时间先后顺序组成的序列，序列点的表征方式是轨迹主要表示方式。</p>
</li>
<li>
<p>轨迹点组成序列的方式直观、简单，但也存在<u>信息冗余</u>，<u>直接适用的数据挖掘和机器学习模型少</u>等不足，同时<u>序列点表征没有将轨迹的时空信息融合在一起</u>，无法体现轨迹数据的时空耦合性</p>
</li>
<li>
<p>为了能从轨迹数据中发现更多的新知识，<strong>将轨迹原始数据转化或学习新的轨迹表征</strong>成为一种重要的研究思路。</p>
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129193217.png" alt="" /></p>
</li>
</ul>
</li>
<li>
<p>第二段：轨迹数据表征基本方法：关键点、子轨迹、轨迹物理特征</p>
<ul>
<li>轨迹中的轨迹点重要性不尽相同，其中部分轨迹点代表轨迹数据中的关键信息</li>
<li>利用轨迹中的关键点作为轨迹数据的表征，能够减少轨迹数据量提高表征质量</li>
<li><strong>关键点</strong>分类
<ol>
<li>在人类出行轨迹中，对人类活动有特殊意义的关键位置点
<ol>
<li>用户在连续较近的地理位置长时间停留的<strong>停留点</strong></li>
<li>根据轨迹点密度或用户偏好得到的<strong>兴趣点</strong></li>
</ol>
</li>
<li>对轨迹形状有影响的关键点，如拐点或轨迹压缩中的保留点</li>
</ol>
</li>
<li><strong>子轨迹段</strong>是研究轨迹局部性质的重要表征方式</li>
<li><strong>轨迹物理特征</strong>：关键点表征与子轨迹段表征是基于轨迹形状的表征方式，另有一些研究人员通过<u>提取轨迹速度、起始点、方向、加速度等特征</u>，用<u>可解释的物理特征向量</u>表示轨迹或子轨迹。</li>
<li>总结：关键点、子轨迹、轨迹物理特征提取三种轨迹表征方式是研究轨迹数据的基本方法，简单直观利于理解，是轨迹数据表征基础方法。</li>
</ul>
</li>
<li>
<p>第三段：将轨迹数据转化为图表征</p>
<ul>
<li>关键：如何准确将轨迹数据表征为图里的点和边</li>
<li>路网</li>
<li><strong>自由空间</strong>：郑宇：首先通过密度聚类算法识别轨迹中的<u>关键点</u>，然后根据密度构建一个<u>层次化的树状结构</u>进一步提取高价值位置，树中的节点作为顶点，所有用户共享顶点集，<u>用户根据自己的轨迹历史数据构建自己的轨迹数据图</u>。至此，<u>度量两个用户轨迹相似度转化为度量两个图的相似度</u>，将图挖掘算法应用至轨迹数据挖掘中</li>
</ul>
</li>
<li>
<p>第四段：将轨迹数据转化为矩阵表征 ➡️ 位置推荐和用户潜在兴趣挖掘</p>
</li>
<li>
<p>第五段：表征学习：将轨迹数据转化为特征空间中的向量表征</p>
<ul>
<li>轨迹数据表征学习
<ul>
<li>目的：自动提取轨迹数据特征，并用特征向量表征轨迹数据</li>
<li>关键：学习轨迹数据的空间和时间信息</li>
<li>轨迹相似度：利用<u>欧式距离度量</u>两条轨迹特征向量的距离，无需设计复杂度较高的距离函数</li>
<li>目前的轨迹数据表征学习研究往往从单一侧面展开，割裂时间和空间之间的紧密偶合关联，对轨迹数据时空耦合分析还很欠缺</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="位置预测研究相关理论">位置预测研究相关理论</h3>
<p><u><strong>以后感兴趣再细看吧</strong></u></p>
<ol>
<li>
<p>第一段：绪言</p>
<ul>
<li>
<p>轨迹数据中的预测问题：主要的研究方向为<strong>交通流的预测和位置或行为预测</strong></p>
</li>
<li>
<p>人类活动在时空维度上有很大的复杂性，但是也表现出了一定的统计规律特性</p>
</li>
<li>
<p>位置预测主要研究预判用户未来会到达的具体位置，位置推荐是通过分析用户偏好模型，为用户推荐感兴趣的地点</p>
</li>
<li>
<p>分类：</p>
<ul>
<li>位置预测根据<u>预测方法</u>不同分为八类</li>
<li>根据个体<u>模型</u>或群组模型分为三类</li>
<li>轨迹数据有位置社交网络的签到<u>数据</u>(check­in) 与 GPS 出行数据两种</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129194150.png" alt="" /></p>
</li>
</ul>
</li>
</ol>
<h2 id="第三章-基于图卷积神经网络的位置语义推断">第三章 基于图卷积神经网络的位置语义推断</h2>
<h3 id="引言">引言</h3>
<ul>
<li>位置社交网络中用户签到活动 ➡️ 签到位置的语义:揭示用户活动的目的和用户偏好 ➡️ 位置语义推断</li>
<li>已有研究表明
<ul>
<li>用户的签到活动与位置语义存在某种潜在关系
<ul>
<li>表明用户签到偏好与位置语义之间存在联系</li>
<li>例如，经常访问图书馆、书店、学校等类似地点的用户很少访问夜店、酒吧等地。</li>
</ul>
</li>
<li>相似空间结构与相似的时间模式的地点具有相近的语义
<ul>
<li>表明在城市规划建设时，具有相同职能的位置建设规划相似</li>
<li>例如，居民区附近普遍有超市、医院、市场等配套</li>
</ul>
</li>
<li>现有位置语义推断算法
<ul>
<li>通过度量用户出行行为间相似度转化为位置特征，进而推断相似签到位置的语义</li>
<li>提取用户签到活动的出行模式，从中提取位置特征，推断位置语义</li>
<li>但度量用户签到行为相似度，<strong>手工提取</strong>位置特征或提取长效有价值的签到活动出行模式<strong>是一项有挑战性的工作</strong></li>
</ul>
</li>
<li>本研究
<ul>
<li>为了解决现有方法通过手工提取特征或出行模式的不足，同时充分利用签到活动中的高阶信息</li>
<li>基于图卷积神经网络的位置语义推断算法框架（SI-­GCN）
<ol>
<li>无监督地提取用户、位置的时空特征
<ul>
<li>node2vec学习位置的空间结构特征</li>
<li>变分自编码器学习时间信息的特征</li>
</ul>
</li>
<li>构建用户­-位置访问二部图，利用图卷积神经网络获取用户签到活动中的高阶信息用以推断位置语义</li>
<li>引入注意力机制区分二部图中邻居节点的不同影响</li>
</ol>
</li>
</ul>
</li>
<li>贡献
<ol>
<li>利用无监督方式提取用户、位置的时空特征</li>
<li>利用图卷积神经网络获取用户签到活动中的高阶信息用以推断位置语义</li>
<li>良好的语义推断性能</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="si-gcn框架">SI-GCN框架</h3>
<h4 id="三部分">三部分</h4>
<ol>
<li>
<p>时空特征提取</p>
</li>
<li>
<p>用户-位置访问二部图</p>
</li>
<li>
<p>位置语义推断</p>
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129202331.png" alt="" /></p>
</li>
</ol>
<h4 id="位置时空特征提取">位置时空特征提取</h4>
<ol>
<li>
<p>位置空间特征提取		<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129203037.png" alt="" /></p>
<ul>
<li>手工提取特征 ➡️ 无监督方法提取</li>
<li>Step 1. 用户映射至地理空间
<ul>
<li>除去用户家以外，选取用户访问频率最高的 3 个访问位置代表用户常去的地理空间活动范围</li>
<li><u>使用 3 个位置的平均经度、纬度作为用户 u 的地理坐标</u></li>
</ul>
</li>
<li>Step 2. 构造地理空间网络
<ul>
<li>将用户、地理位置看作<strong>节点</strong>，通过计算节点间距离</li>
<li>若距离小于 δ 时，两节点相连构成<strong>边</strong>，否则不构成边</li>
</ul>
</li>
<li>Step 3. 空间特征提取算法
<ul>
<li>采用 node2vec 算法无监督学习用户、地理位置的空间特征表达</li>
<li>目标是在地理空间网络中的节点与邻居节点共同出现的概率最大 ➡️ 最大化邻居节点的出现概率</li>
</ul>
</li>
</ul>
</li>
<li>
<p>位置时间特征提取<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129203943.png" alt="" /></p>
<ul>
<li>目标是学习用户访问的时间模式以及地理位置的被访问的时间模式</li>
<li>Step 1. 建立 7 × 24 的时间矩阵，计算用户访问时间、位置的被访问时间得到时间矩阵
<ul>
<li>例如，用户 A 在周一上午 9 点10 点访问位置 B，则时间矩阵相应元素加 1</li>
<li>位置的时间矩阵与用户的时间矩阵计算方法一致</li>
</ul>
</li>
<li>Step 2. 采用变分自编码器无监督学习时间矩阵的特征向量</li>
<li>Step 3. 完成网络学习后，提取变分<u>自编码器的隐层输出</u>得到用户、地理位置的时间特征</li>
</ul>
</li>
<li>
<p>将用户、地理位置的空间特征、时间特征直接相连，构成时空特征</p>
</li>
</ol>
<h4 id="图卷积神经网络推断模型">图卷积神经网络推断模型</h4>
<ol>
<li>用户­-位置访问二部图：反映用户与地理位置之间的访问关系与拓扑结构<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129204550.png" alt="" /></li>
<li>利用图卷积神经网络将用户-­位置访问二部图的拓扑关系、用户和地理位置的时空特征相结合探索位置的语义</li>
</ol>
<h3 id="实验与分析">实验与分析</h3>
<ol>
<li>
<p>实验</p>
<ul>
<li>数据集：FourSquare 提供的纽约市 (NYC) 和东京市 (Tokyo)签到数据集<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201129212503.png" alt="" />
<ul>
<li>实验中移除了访问次数少于 10 次的位置</li>
<li>设置两种语义标签策略
<ul>
<li>所有的标签归为 10 大类</li>
<li>签到次数排序前 20 的位置语义标签</li>
</ul>
</li>
</ul>
</li>
<li>选择了三种基准位置语义推断算法作为对比</li>
<li>参数：空间特征维度为 200，时间特征维度为 16，因此用户、位置时空特征为 216 维</li>
<li>为了充分评估模型性能，完成提取位置时空特征后，训练图卷积神经网络时，<u>分别采用 80%，70%，60%，50% 的训练数据训练模型，对应 20%，30%，40%，50% 的测试数据测试模型</u>。</li>
</ul>
</li>
<li>
<p>结果与分析</p>
<ul>
<li>数据类别分布不平衡对模型性能影响明显</li>
<li>在纽约市数据集的结果好于东京市数据集的结果 ➡️ 纽约市每名用户访问过更多位置，使模型能够获得更多信息</li>
<li>不同训练数据比例的实验结果表明，SI­-GCN 语义推断性能稳定，实验结果没有显著降低。</li>
<li>不同特征对 SI­GCN 模型语义推断性能的影响 ➡️ 缺失任何一种特征对模型都会产生较大影响，所有评价指标都有下降</li>
<li>自注意力机制使节点能够捕捉数据内部的相关性，减少其他信息的干扰。
<ul>
<li>移除自注意力机制后，模型整体性能有显著下滑，但部分实验结果优于移除特定特征模型的结果，说明位置的时空特征对 SI­GCN 模型性能有更重要影响。</li>
<li>自注意力机制对模型性能提升是<strong>正面的</strong>，自注意力机制加权处理邻居节点信息，有效提高模型性能。</li>
</ul>
</li>
<li>SI­GCN 结果明显优于三种基准算法的位置语义推断性能</li>
</ul>
</li>
</ol>
<h2 id="第四章-融合时空结构的轨迹数据表征学习">第四章 融合时空结构的轨迹数据表征学习</h2>
<h3 id="引言-1">引言</h3>
<ul>
<li>不同定位设备采集，不同采样率与轨迹长度 ➡️ 轨迹数据表征困难</li>
<li>现有大多数轨迹表征研究割裂时间与空间之间的紧密耦合，仅从单一维度（通常是空间维度）表征轨迹数据：（1）以往关注轨迹数据空间结构表征，忽略轨迹的时间信息；（2）以往表征方式不适用于普遍的机器学习与数据挖掘模型；（3）欠缺语义信息嵌入</li>
<li>本文提出一种<strong>统一的框架</strong>——融合时空结构的轨迹表征学习算法框架（Space-Time Architecture for semantic trajectory Representation, STAR）
<ul>
<li>上下文信息+词向量表征学习算法学习轨迹空间结构信息</li>
<li>自适应霍克斯过程建模轨迹时间信息</li>
<li>轨迹向量表征作为<strong>桥梁</strong>连接融合轨迹时空信息</li>
<li>通过<strong>预测用户位置和时间</strong>的过程自动学习轨迹表征</li>
<li>主成分分析（PCA） ➡️ 检测异常轨迹</li>
</ul>
</li>
<li>贡献
<ul>
<li>融合时空信息</li>
<li>语义嵌入</li>
<li>在轨迹表征向量基础上提出<strong>轨迹异常检测算法</strong></li>
</ul>
</li>
</ul>
<h3 id="框架概述">框架概述</h3>
<ul>
<li>三部分：空间表征、轨迹时间建模、时空融合<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201207160147.png" alt="" /></li>
</ul>
<h3 id="轨迹表征学习模型">轨迹表征学习模型</h3>
<h4 id="轨迹空间信息向量表征">轨迹空间信息向量表征</h4>
<p>三种上下文的提出还是蛮有意义的</p>
<ul>
<li>
<p>词向量表征学习介绍 + word2vec + CBOW</p>
</li>
<li>
<p>类比思想：将用户轨迹中的用户兴趣点类比于自然语言领域文本中的单词，将用户轨迹类比于文本中的句子</p>
</li>
<li>
<p><strong>轨迹与文本两者之间的上下文信息有所差别</strong>，因为兴趣点语义信息相近，并不一定在地理上相邻 ➡️ 需要重新定义给定<strong>兴趣点的上下文信息</strong><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201207161655.png" alt="" /></p>
<ul>
<li>地理上下文</li>
<li>轨迹上下文</li>
<li>语义上下文：
<ul>
<li>1­阶熵：1­阶熵是给定兴趣点与其 1­阶邻居连接强度的分布熵</li>
<li>2­阶熵和聚类系数：2­阶熵进一步获取了连接强度 2­阶邻居范围内的整体分布</li>
<li>聚类系数：考虑连通密度，计算聚类系数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>根据上述兴趣点的上下文邻域，通过 CBOW 模型学习<strong>兴趣点和轨迹</strong>的向量表征</p>
</li>
</ul>
<h4 id="时间信息建模">时间信息建模</h4>
<p>没看懂</p>
<ul>
<li>
<p>点过程</p>
</li>
<li>
<p>条件强度函数：在给定历史数据的条件下，新事件在单位时刻内发生的瞬时率</p>
</li>
<li>
<p>霍克斯过程：泊松过程的一个扩展</p>
</li>
<li>
<p>霍克斯过程比传统泊松过程更能够模拟过去事件对未来事件发生的影响，特别是过去事件对未来事件的正面激励影响</p>
<h4 id="基于轨迹表征的异常检测">基于轨迹表征的异常检测</h4>
</li>
<li>
<p>现有的轨迹异常检测算法主要利用轨迹距离度量、轨迹密度、子轨迹片段划分等空间形状，或轨迹异常模式检测异常轨迹</p>
</li>
<li>
<p>本文：分析轨迹数据表征中数据的主要成分信息，检测偏离主要成分信息的轨迹</p>
</li>
<li>
<p>异常分数表示轨迹异常程度，即异常轨迹与轨迹数据主成分的偏离程度，选择一个阈值来区分异常轨迹</p>
</li>
</ul>
<h3 id="实验与分析-1">实验与分析</h3>
<ul>
<li>数据<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201207164428.png" alt="" /></li>
<li><strong>兴趣点提取</strong>：为了有效分析轨迹中的重要信息，实验提取轨迹数据集中的兴趣点，减少无效信息有助于分析轨迹表征学习算法的性能。将研究区域划分为 n × n 的网格（实验中设置 n = 100）。计算落在网格中 GPS 点的经纬度的平均值和时间信息，计算单元网格地理距离的相似度矩阵，最后使用 K­means 聚类方法提取 K 个兴趣点 (POIs)，本章实验中设置所有数据集K = 1000</li>
<li>语义标签标注：将兴趣点语义类别分为八种，包括风景区、公园、村庄、社区、交通、商务区、医院和教育。</li>
</ul>
<h2 id="第五章-基于偏好社交互动的位置预测算法">第五章 基于偏好社交互动的位置预测算法</h2>
<h3 id="引言-2">引言</h3>
<ul>
<li>位置预测是轨迹分析中的一项重要任务，位置预测的目标是分析人类的出行轨迹数据，<u>从历史数据中学习人们的出行模式预测未来人们到访的位置</u></li>
<li>个体的出行行为并不完全是规律的，且会受到外部因素的影响而发生变化</li>
<li>人类行为主要受<u>自身偏好与外部社交</u>两方面影响</li>
<li>本文提出——基于偏好社交互动的位置预测算法（Preferences and Social Interactions for location prediction, PSI）：
<ul>
<li>首先量化外部互动对个人出行行为的影响，利用聚类技术确定<u>个人所属的关联群组</u></li>
<li>然后采用关联规则挖掘方法，提取反映外部互动影响的群组频繁出行模式</li>
<li>最后，利用岭回归整合群组移动模式与个人出行模式，预测用户位置</li>
</ul>
</li>
<li>贡献：
<ul>
<li>双层聚类的兴趣点：热点兴趣点和普通兴趣点</li>
<li>基于偏好社交互动的位置预测算法</li>
<li>采用北京行人出行数据集和波尔图市的出租车数据集对 PSI 进行实验分析</li>
</ul>
</li>
</ul>
<hr />
<h1 id="基于地理场景的城市功能区建模与分析方法研究">基于地理场景的城市功能区建模与分析方法研究</h1>
<ul>
<li>张修远-2019-北京大学，师从杜世宏</li>
</ul>
<h2 id="札记">札记</h2>
<ul>
<li>写作用词套路：<strong>提出了-应用于-能够-实现了</strong></li>
</ul>
<h2 id="摘要-2">摘要</h2>
<ul>
<li>
<p>第一段：背景-问题-本文目的</p>
<ul>
<li>全球城市化发展-城市问题</li>
<li>响应我国<strong>城市可持续发展</strong>的重大战略规划➡️需要获取高时效、 高精度、大范围的<strong>城市功能分区数据</strong></li>
<li>已有研究通常使用<strong>城市规划图</strong>表征功能分区信息
<ul>
<li>规划图仅反映<u>某一时间区间内</u>对功能区建设的<strong>预期目标</strong>，不能反映<u>当前时刻</u>城市功能分区的<strong>真实状态</strong></li>
<li>规划图以街区为基本单元， 忽视了街区内部功能类型的异质性， 进而无法在<u>更精细的尺度上</u>分析功能分区情况</li>
</ul>
</li>
<li>因此，本文致力于
<ul>
<li>发展一种<strong>自动化城市功能区制图</strong>的解决方案</li>
<li>重点解决功能区的<strong>空间单元提取、 结构格局表达和功能类别智能识别</strong>等关键问题</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第二段：从遥感数据角度分析，背景-阐述难点-本文目的</p>
<ul>
<li>基于高分辨率遥感影像的高时效、大范围功能区制图</li>
<li>城市功能区作为一种<strong>地理综合体</strong>：综合性、异质性以及尺度不确定性
<ul>
<li>综合性：城市功能区的空间单元是由多种地物要素按照一定空间分布规律聚合而成， 而其语义类别是<u>概括这些地物的利用类型</u>通过而获得的， 因此功能区在空间组成上和语义类别上具有综合性。</li>
<li>异质性： 城市中不同类型的功能区（如商业区、居民区、工业区）在<u>空间上分布不均匀</u>， 且每个功能区内部<u>地物组成和空间结构多变</u>， 是不同类型社会经济活动共同作用的结果。</li>
<li>尺度不确定性： 城市功能区的分析结果在<u>不同尺度上有不同表现</u>， 本质上城市功能和地物要素在不同的尺度上耦合关联， 不同的分析尺度有助于分析调查不同粒度的地物结构以及功能类别。</li>
</ul>
</li>
<li>难点：三个特性互相关联， 导致<u>功能区建模与分析的难度远大于地物识别与分析的难度</u>， 因此<u>已有的遥感影像分析方法</u>无法准确地提取功能区的空间单元、 结构格局和语义类别。</li>
<li>为解决此问题（他的用词很有讲究吧）
<ul>
<li><em>原创性</em>地提出了基于<strong>地理场景</strong>的遥感影像分析方法</li>
<li>
<ul>
<li>应用于*城市功能区<strong>自动分割提取、特征表达和智能识别</strong></li>
</ul>
</li>
<li><em>能够</em>准确<strong>提取和表达功能区空间单元、 结构格局和语义类别</strong></li>
<li><em>实现</em>功能区的<strong>自动化制图</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第三-六段：论文研究成果概述</p>
<ul>
<li>功能区空间单元分割及提取
<ul>
<li>已有分割算法没有考虑城市功能区<strong>综合性和异质性</strong>的影响， <u>不能从遥感影像中分割提取功能区空间单元</u>
<ul>
<li>提出了基于<strong>多要素</strong>聚合的<strong>多尺度</strong>地理场景分割方法</li>
<li><em>解决了</em>功能区的<strong>异质性度量以及自动聚合</strong>等难题</li>
<li><em>实现了</em>在不同尺度上分割提取功能区单元</li>
<li>以满足<em>不同粒度</em>城市调查和规划的需求</li>
</ul>
</li>
<li>功能区的<strong>尺度不确定性</strong><u>对分割结果和效率造成不利影响</u>
<ul>
<li><em>进一步</em>提出了<strong>自适应</strong>分割尺度学习方法</li>
<li>通过<strong>局部尺度评估方法</strong>， 自动确定每个功能区的<strong>最佳分割尺度</strong>，进而优化分割结果，提高功能区提取的精度和效率。</li>
</ul>
</li>
</ul>
</li>
<li>功能区空间单元表达
<ul>
<li>功能区的<strong>异质性</strong>极大<u>减弱了现有影像特征对功能区的表达能力</u>
<ul>
<li>提出了<strong>空间语义共生模型</strong></li>
<li>度量功能区中不同地物要素在空间和语义上的依赖关系，表达功能区的空间格局</li>
<li>并<em>在数学上证明了</em>该特征的鲁棒性</li>
</ul>
</li>
<li>受功能区<strong>综合性</strong>的影响，<u>单一特征无法全面表达功能区</u>
<ul>
<li><em>进一步</em>提出了<strong>层次语义认知模型</strong></li>
<li>对<strong>多源特征</strong>（包括视觉特征、语义特征、空间共生特征） 进行分层组织</li>
<li>并建模了不同特征间的层次依赖概率，用于功能区多源特征及其层次关联结构表达。</li>
</ul>
</li>
</ul>
</li>
<li>结构格局和语义类别
<ul>
<li>功能区综合性、异质性和尺度不确定性， 导致<u>功能区样本选择、 分类识别困难</u>
<ul>
<li>基于<strong>主动学习</strong>， 提出了启发式样本学习方法</li>
<li>兼顾纯净样本和混淆样本， 能够自动获<strong>取代表性样本</strong>用于功能区监督分类</li>
</ul>
</li>
<li>功能区分类
<ul>
<li>建立了连续多项式分布模型， 表达功能区之间的<strong>空间依赖性</strong></li>
<li>优化提高了功能区分类制图精度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>第七段：</p>
<ul>
<li>研究思路
<ul>
<li>图像特征➡️土地覆盖➡️空间结构➡️功能分区</li>
<li>对现有遥感影像分类范式的有效拓展</li>
</ul>
</li>
<li>提出了一套基于地理场景的城市功能区分析理论和方法体系
<ul>
<li><em>应用于</em>功能区分割提取、 特征表达和分类识别</li>
<li><em>能够</em>准确地提取功能区的空间单元、 结构格局和语义类别</li>
<li><em>实现了</em>自动化的城市功能分区制图</li>
</ul>
</li>
<li>论文研究方法和结果
<ul>
<li>可为城市规划、城市可持续发展评估提供详细尺度、高精度、 时效性强的城市功能分区数据</li>
<li>对城市可持续发展规划与建设具有重要的推动作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第一章-绪论">第一章 绪论</h2>
<h3 id="论文研究背景与意义">论文研究背景与意义</h3>
<ul>
<li>第一段
<ul>
<li>全球城市化建设进程-我国城市化建设</li>
<li>城市化的高速发展-许多自然和社会问题-城市可持续发展</li>
<li>城市化-<strong>功能区作为城市化建设的基本地理单元，是研究和调查城市化进程的关键</strong></li>
<li>城市功能区制图</li>
</ul>
</li>
<li>第二段：<font color='red'>城市功能区的概念及发展</font>
<ul>
<li>源于区域经济学
<ul>
<li>首次提出：同类经济活动集中的连片地区</li>
<li>引入环境科学领域</li>
<li>城市景观生态分析</li>
</ul>
</li>
<li>功能区在城市问题分析中扮演着重要的角色
<ul>
<li>区域经济学中城市功能区这一<strong>概念比较模糊</strong>， 无法体现功能区的构成要素、形成机理</li>
<li>Tyler and Ward 从城市规划的角度给出了一个新的定义：<strong>城市功能区指由不同地表要素构成的地理综合体， 每个功能区内部具有相对一致的建成环境和人类社会经济活动。</strong>(Tyler, N., &amp; Ward, R. M. (2011). Planning and community development: A guide for the 21st century. WW Norton.)</li>
</ul>
</li>
</ul>
</li>
<li>第三段，功能区分析中的难点问题
<ul>
<li>在地理表现上，呈现出<font color='red'>（1） 综合性和（2） 异质性</font>
<ul>
<li>城市功能区的综合性：多种地物<strong>要素</strong>组成、具有一定建成<strong>环境</strong>或景观格局、在规划建设和历史因素作用下这些地物要素的空间分布、 排列呈现出一定<strong>规律</strong></li>
<li>综合性是<strong>功能区分析的基础</strong>
<ul>
<li>这一特性明确了功能区内部地物的分布特点，可以作为提取功能区的依据</li>
<li>综合性还是功能区在地理表现上的最基本特性，它也直接导致了功能区的异质性和尺度不确定性</li>
</ul>
</li>
<li>城市功能区的异质性
<ul>
<li>每个城市包含<strong>不同的功能区</strong>（如商业区、工业区、居民区、学校、公园） 且这些功能区在空间上<strong>交错且不均匀</strong>地分布</li>
<li><strong>功能区在内部组成和结构上表现异质</strong>（这一点以前确实没有理解到），例如居民区中包含了建筑物、植被、裸土、道路，这些土地覆盖要素又具有不同的空间结构。</li>
<li>功能区的异质性是由人类不同的社会经济活动作用<strong>形成</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>在分析中存在<font color='red'>（3）尺度不确定性</font><br />
-功能区<strong>分析结果随分析尺度的变化而变化</strong>， 本质上是城市功能和地物要素可以在不同的尺度上<strong>耦合关联</strong>， 不同的分析尺度可以用于调查不同<strong>粒度</strong>的地物结构以及功能类型
<ul>
<li><font color='red'>例如在较大的尺度上才能分析调查学校功能区，而在较小的尺度上学校则被划分为了宿舍居民区、教学区甚至还包含了商业区和公园（这个例子举得很经典）</font>?</li>
</ul>
</li>
<li>三个基本特性是基于遥感影像功能区分析中的难点， 这三个特性增大了提取功能区空间单元和语义类别的难度</li>
<li>综上所述：城市功能区在地理表现上的<strong>三个基本特性</strong>导致<strong>功能区建模与分析</strong>异常困难， 使其难度远大于传统的<strong>地物识别与分析</strong>的难度，因此在城市功能区分析中需要考虑和解决上述三个难点。</li>
</ul>
</li>
<li>第四段
<ul>
<li>传统的城市功能区调查与分析<strong>基于历史规划数据</strong>进行
<ul>
<li>在城市规划与建设中，规划人员<u>以土地覆盖现状和社会经济属性为基础</u>， <u>以城市发展为导向</u>， <u>设计城市规划图实现对功能区的划分和表达</u>， 其<u>最详细到街区尺度最粗略到城市群尺度</u></li>
<li>城市规划图不足：
<ul>
<li>本质是<strong>针对某段时间区间内</strong>城市建设的指导方案， 并<u>无法反映当前或某一个时间节点上</u>城市功能区的真实情况</li>
<li>规划图以<strong>街区</strong>作为最详细尺度<u>忽略了街区内部功能类型混淆的情况</u>， 因此无法准确地表达<u>功能区的空间范围</u></li>
</ul>
</li>
<li><strong>基于城市规划图的功能区建模与分析是不准确的</strong></li>
</ul>
</li>
<li>基于地理大数据的功能区调查方法逐渐兴起 ➡️ 城市功能区的动态检测</li>
<li>本文：
<ul>
<li>基于高分遥感影像结合街道、兴趣点等<strong>多源地理数据</strong><font color='red'>提出了</font>地理场景的建模与分析方法，将其<font color='red'>应用于</font>城市功能区制图与分析</li>
<li><font color='red'>解决了</font>功能区分析中三个难点问题，<font color='red'>实现了</font>功能区的自动提取、 综合表达与智能识别</li>
<li><font color='red'>在技术上</font>，<font color='red'>创新性地提出了</font>地理场景场景分割、自适应尺度优化、空间语义特征提取、 多源特征组织与表达、功能区样本学习、 功能分类等关键技术难点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于地理场景的功能区分析中基本概念">基于地理场景的功能区分析中基本概念</h3>
<p>本质上，是利用影像中地理场景对城市功能区进行建模提取， 在此基础上提取功能区的描述特征， 进而实现对功能区的分类识别。</p>
<h4 id="城市功能区相关概念及分类体系">城市功能区相关概念及分类体系</h4>
<ul>
<li>城市功能区的空间约束条件是城市范围
<ul>
<li>什么是城市
<ul>
<li>在经济学中</li>
<li>在城市规划学中</li>
<li>在地理学中（本文中参考）：<strong>城市是指交通网络密集，人群和房屋的密集的结合体</strong></li>
</ul>
</li>
</ul>
</li>
<li><font color='red'>概念对比：城市功能区与土地利用</font>
<ul>
<li>土地利用是指<font color='red'>人类根据一定的社会经济目的对土地覆盖进行长期性或周期性的经营管理和治理改造</font>（Anderson, 1976）</li>
<li>相同点：土地利用和功能区的<u>基本组成单元都是土地覆盖，都涉及到社会经济活动</u></li>
<li>不同的是：功能区在定义中<strong>强调了区域的空间范围，而土地利用则没有对空间范围进行约束</strong></li>
<li>一个土地利用要素可以是由一个土地覆盖要素构成的利用类型，也可以是由多个土地覆盖要素组成的利用分区；而功能区一定是由多个不同的土地覆盖要素组成的。</li>
<li>功能区可视为土地利用的子集<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105171826.png" alt="" /></li>
</ul>
</li>
<li>城市功能区分类体系
<ul>
<li>参考：我国《城市用地分类与规划建设用地标准》 (Code for classification of urban land use and planning standard of development land, GB 50137-2011)</li>
<li>将我国城市划分为<u>商业区、工业区、居民区、 <strong>城中村</strong>、 教育用地（一般指学校）、 公共开放区（如公园）（后续可以参考文中对每一类功能区的解释，这里拷贝过来了）</u><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105172503.png" alt="" />
<ol>
<li>商业区（图 1.3 a）。<strong>商业区是指零售商业聚集、交易频繁的地区以及大型写字楼办公区</strong>（详见《城市用地分类与规划建设用地标准》）。商业区在地理空间上多分布于城市中心和经济开发区，常位于交通路口、繁华街道两侧、大型公共设施周围。 商业区中建筑物一般较为高大且建筑结构复杂。在大城市或特大城市中商业区又常被划分为中央、区和街等不同层次、规模的商业区， 在本论文所研究的商业区为具有一定规模且商业活动聚集区域， 因此居民区内部规模较小的商业服务设施属于居民区， 不属于本论文中商业区范畴。</li>
<li>工业区（图 1.3 b）。 <strong>工业区包括制造生产资料或大型器械的重工业区以及生产日常消耗用品的轻工业区。</strong> 在城市中， 工业区多由加工工业企业群组成，一般情况下，其内部结构比较协调，并有紧密的生产联系。由于城市的整体职能不同，城市中工业区的地理表现也不同。例如，工业城市与旅游城市的工业区大小、形态以及空间分布都有差异，但是一般来说城市工业区在空间上集群分布，多位于城市郊区或城乡结合带。工业厂房房顶的材质和颜色与城市中其它建筑物有很大差别。 本论文所涉及的工业区包括重工业区以及大规模的轻工业区，而混杂在其它功能区中的小型加工厂、手工作坊不属于本论文工业区范畴。</li>
<li>居民区（图 1.3 c）。 **居民区泛指城市常住人口居住的社区， 包含其配套设施。**居住区是城市中主要的用地组成部分， 散布在城市的各个区域。 根据居民区中居住环境、 配套设施， 可以将居民区分为一级居民区（高档居民区）、 二级居民区（普通居民区） 和三级居民区（老旧居民区）。 一级居民区一般由别墅、新式高层建筑组成，常配套有健身房、绿地等生活设施；二级居民区一般是由不高于 9 层的中层居民楼构成，分布规则排列有序，周边有一定的配套设施，如小超市、餐馆等，该类型居民区分布最为广泛，遍布城区； 三级居民区是由不高于 4 层的老式居民楼构成， 周边配套设施较少，该类居民区常出现在老城区。 论文中的居民区包括以上三种居民区。</li>
<li>城中村（图 1.3 d）。**城中村是城市中一种特殊的功能区类型，是城镇化建设过程中未开发建设但周围都已形成城市结构的区域。**该区域仍保留乡村的建筑结构（低矮的房屋、密集的建筑分布）和老式的社区形态， 拥有较少的、规模较小的配套服务设施。 但是由于位于城市建成区内部， 城中村中居住人口、基础设施等又与乡村相比具有明显差异。</li>
<li>学校（图 1.3 e）。 **学校包括幼儿园、小学、中学以及高校。**此功能区内部组成一般比较复杂，包含了宿舍、超市、教学楼、办公楼、操场等。 论文中所研究的学校包括具有一定规模的小学、 中学和高校， 而居民区配套的幼儿园以及小规模的小学属于居民区， 而不属于学校范畴。</li>
<li>公园（图 1.3 f）。**公园是指政府修建并经营的作为自然观赏区和供公众的休息游玩的公共开放区域， 一般是由政府规划建设或历史因素形成的。**根据上述定义， 由地产开放商建设的居民区、 商业区内的观赏和休闲区不属于论文中公园的范畴， 此外，有学校经营和管理的观赏休闲区也不属于公园的研究范畴。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="地理场景相关概念">地理场景相关概念</h4>
<ul>
<li>场景
<ul>
<li>在计算机视觉领域， 场景常被用于形容一幅图片所包含的内容，例如“海岸”、“高山”、“森林”、“乡村”、“街道”和“建筑物”。 ➡️  几乎任何一幅图片都可以被视为一个场景。 计算机视觉中<strong>图片场景缺乏一个明确的定义</strong>。</li>
<li>场景被用于描述高分遥感影像
<ul>
<li>最著名的遥感影像场景数据库是 UC Merced Land Use（http://vision.ucmerced.edu/datasets/landuse.html）</li>
<li>遥感影像场景分类</li>
</ul>
</li>
<li>现状/问题：无论是图片场景还是遥感影像场景对<strong>其含义、 构成要素、 形成规则都缺乏明确的定义</strong>， 因此<strong>无法给出相应的数学形式化建模方法</strong>。
<ul>
<li>上述场景都是<strong>基于人的主观认知使用规则栅格划分</strong>提取的， 而这些栅格本身是<strong>缺乏地理含义</strong>的， 因为<strong>栅格划分无法表达地理要素的空间单元， 进而难以准确地表达地理要素的语义类别</strong>。</li>
</ul>
</li>
<li>结论：<font color='red'>故已有的图片场景和遥感影像场景不适用于建模分析城市功能区这种地理综合体。</font></li>
</ul>
</li>
<li>地理场景
<ul>
<li>地理场景是<u>由多种土地覆盖对象组成的图像块， 每个地理场景内同类型的土地覆盖对象具有相似的个体特征和空间分布特征</u>。 例如图 1.6（c）中建筑物具有相似的颜色、形状、朝向，形成整齐的排列方式，其他土地覆盖具有类似的规律，因此将这样的一个图像区域称为地理场景。<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105193714.png" alt="" /></li>
<li>数学形式化表达</li>
<li>是一种地理分异单元。具有明显的地理含义</li>
<li>地理场景不同于传统的图像单元
<ul>
<li>像素是传感器成像的基本物理单元，是图像上最小的可区分单元</li>
<li>对象是图像中颜色纹理均质且连续的区域</li>
</ul>
</li>
<li>对象与场景的区别</li>
</ul>
</li>
</ul>
<h3 id="研究现状与存在问题">研究现状与存在问题</h3>
<h4 id="引言-3">引言</h4>
<ul>
<li>该领域研究方法</li>
</ul>
<ol>
<li>基于社交媒体定位数据的功能区分析， 社交媒体定位数据是指社交媒体平台上产生的具有位置信息和语义信息的有价值数据</li>
<li>基于感兴趣点（Point of interests, POI）数据的功能区分析， POI 数据泛指一切人类感兴趣的位置点数据，通常 POI 数据用于导航包含点的位置、 属性和利用信息</li>
<li>基于遥感影像数据的城市功能区分析</li>
</ol>
<ul>
<li>论文以遥感影像为本底数据，结合 POI 信息对城市功能区进行建模和分析，其主要研究思路包括功能区分割提取、特征表达和分类识别 <img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105205833.png" alt="" /></li>
<li>基于遥感影像的城市功能区建模与分析中共存在<strong>六个关键问题</strong></li>
</ul>
<h4 id="城市功能区分割提取的研究现状和存在问题">城市功能区分割提取的研究现状和存在问题</h4>
<ul>
<li>问题一，功能区分割方法问题：传统分割算法都是为了提取视觉特征均质的图像对象，而城市功能区包含多种土地覆盖要素（如水体、植被、建筑物等）， 因此功能区在视觉上是不连续的， 即<strong>功能区表现出很强异质性</strong>。 这使得传统的图像分割方法无法提取城市功能区。</li>
<li>问题二，功能区分割尺度问题：功能区在分割提取时具有<strong>尺度不确定性</strong>，而现有的尺度选择方法无法解决功能区分割提取中尺度不确定性问题</li>
</ul>
<h4 id="城市功能区特征表达的研究现状和存在问题">城市功能区特征表达的研究现状和存在问题</h4>
<ol>
<li>问题三，功能区空间格局特征表达问题：如何提取鲁棒的空间格局特征是功能区特征表达中亟待解决的问题
<ul>
<li>功能区的常用特征主要包括三类：视觉特征、抽象特征、 语义特征<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105214109.png" alt="" />
<ul>
<li>视觉特征：直接从图像中提取的用于描述图像单元的量化指标， 这些指标是基于人类视觉感知经验定义的。视觉特征可进一步分为两类： 图像对象特征、视觉描述子。
<ul>
<li>图像对象特征：目标对象光谱、纹理、 形状、大小等</li>
<li>视觉描述子：梯度方向直方图（Histogram of oriented gradients, HOG） 和尺度不变特征变换（Scale-invariant feature transform, SIFT）</li>
</ul>
</li>
<li>抽象特征：在视觉特征的基础上，利用一些机器学习或者统计学习方法将视觉特征进行抽象和变换从而获得更有意义的特征。
<ul>
<li>主题语义模型 ➡️ 潜在主题特征</li>
</ul>
</li>
<li>对象库（object bank）：每个功能区内部对象语义类别的频率分布</li>
</ul>
</li>
<li>视觉特征的对功能区的表达分析能力较差； 抽象特征可解释性不强； 语义特征能够有效提高功能区的抽象表达能力也具有很强的可解释性， 但是忽略了空间信息；而功能区内部地物的空间格局是表达功能区的关键。<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105214913.png" alt="" /></li>
</ul>
</li>
<li>问题四，功能区特征层次依赖问题：在组合多源特征对功能区进行表达时需要考虑不同特征之间的层次依赖关系， 而现有的特征组合方式忽略了特征之间的层次依赖关系
<ul>
<li>单一特征难以全面地、准确地表达城市功能区➡️<strong>组合不同特征</strong>（视觉特征、抽象特征、 语义特征和空间格局特征）来提高特征对功能区的表达能力
<ul>
<li>常见的特征组合方法是首先将上述所有特征展为多个一维向量， 然后把不同特征首尾串联获得一个超高维的特征向量
<ul>
<li>特征<strong>维度大</strong></li>
<li>这些特征属于<strong>多源异构</strong>特征，即特征的含义、单位和数量级都是不同的</li>
<li>这些高维特征间具有很强的相关性， 因此简单的线性特征组合表达对于功能区分类识别造成不利的影响</li>
</ul>
</li>
<li>视觉特征、抽象特征、语义特征和空间格局特征之间具有<strong>显著的自下而上的层次依赖特性</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="城市功能区分类识别的研究现状和存在问题">城市功能区分类识别的研究现状和存在问题</h4>
<ol>
<li>问题五，功能区样本获取问题：如何准确地选取和标注功能区样本是功能区分类识别中的难点问题</li>
<li>问题六，功能区空间相关性问题：仅考虑功能区内部特征难以准确分类识别功能区类型， 因此需要建模功能区的空间相关性以优化分类结果
<ul>
<li>功能区作为一种地理综合体具有<strong>地理特性</strong>：地理空间上越靠近的事物相似度越高</li>
<li>空间上邻近的功能区具有很强的<strong>相关性</strong>：<font color='red'>例如一个功能区可能属于城中村也可能属于居民区， 如果这个功能区与工业区邻接，那么它大概率属于城中村。</font>因此在分类识别功能区时需要考虑功能区的空间相关信息，但已有分类方法无法建模和表达功能区的空间相关性（这个例子举的很好）</li>
</ul>
</li>
</ol>
<h3 id="研究目标与内容">研究目标与内容</h3>
<ul>
<li>论文致力于实现基于遥感影像的城市功能区分割提取、特征表达以及分类识别，但是受功能区综合性、异质性和尺度不确定性的影响， 引发了六个难点问题。</li>
<li>论文将结合地理学、景观生态学以及计算机视觉等领域的知识， 提取一套基于地理场景的城市功能区建模与分析方法体系， 考虑了功能区的基本特性， 解决了上述难点问题，</li>
<li>并将该方法应用于城市功能区制图和城市功能结构分析等方面。</li>
<li>技术路线<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105222017.png" alt="" /></li>
<li>研究内容遵循功能区提取➡️表达➡️识别的前后逻辑关系</li>
<li>章节安排<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210105222456.png" alt="" /></li>
</ul>
<h2 id="第二章-多尺度地理场景分割功能区分割提取">第二章 多尺度地理场景分割：功能区分割提取</h2>
<h3 id="引言-4">引言</h3>
<h4 id="功能区分割提取的研究背景">功能区分割提取的研究背景</h4>
<ul>
<li>第一段
<ul>
<li>城市功能区是城市规划和管理的<u>基本空间单元</u>➡️</li>
<li><u>获取这些功能区的空间边界信息</u>是进行功能区分析的前提➡️</li>
<li>功能区内部组成和结构异质且<u>功能区边界范围模糊、易混淆</u>，因此<strong>传统的</strong>面向均质对象的分割方法<strong>难以从遥感影像中提取城市功能区</strong>➡️</li>
<li>本章将<u>解决功能区分割方法问题</u>， 致力于自动化、多尺度提取功能区的空间单元</li>
</ul>
</li>
<li>第二段
<ul>
<li>研究历史悠久且近年来也是研究热点</li>
<li>基于高分影像城市功能区分析主要包括三个步骤：功能区分割、 特征表达以及功能分类
<ul>
<li>功能区分割是指将高分遥感影像在空间上分割成不同的区域，使得每个区域代表一个功能区。</li>
<li>其次，特征表达是利用量化特征对每个功能区中的内容进行描述和表达。</li>
<li>最后，功能语义分类是基于功能区的特征表达对每个功能区进行分类以及功能语义标注，实现功能区分类制图。</li>
</ul>
</li>
<li>已有的功能区分析方法中大部分<strong>集中于特征表达和功能分类， 但是忽略了功能区分割</strong>。<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210107202854.png" alt="" /></li>
<li>功能区分割的重要性(最初始、最基础的一步) ➡️</li>
<li><strong>首先应解决</strong>功能区分割的问题➡️</li>
<li>由于综合性和异质性，已有的图像分割方法都无法解决功能区分割提取问题➡️</li>
<li>使用<strong>街区分割</strong>提取城市功能区（道路分割）的不足：
<ul>
<li>欠分割</li>
<li>时间差异导致分割结果不准确</li>
<li>街区分割结果不适合多粒度或多尺度分析</li>
</ul>
</li>
<li><strong>需要提出新的方法实现</strong>基于高分影像的城市功能区分割提取</li>
</ul>
</li>
<li>第三段
<ul>
<li>功能区分割中需要考虑四方面内容：
<ol>
<li>分割依据（功能区异质性表达）：图像特征及其异质性表达是图像分割的主要依据。
<ul>
<li>低层特征
<ul>
<li>光谱、几何和纹理图像特征</li>
<li>能有效表达相对同质的对象， 而不能有效表达由不同对象组成的异质的功能区</li>
</ul>
</li>
<li>中层特征
<ul>
<li>对象语义和视觉词袋</li>
<li>缺乏明确的语义信息，忽略了对象的空间上下文信息，导致分割结果不准确</li>
</ul>
</li>
<li>高层特征
<ul>
<li>卷积神经网络提取高层次深度特征</li>
<li>1）深度特征是基于像素窗口提取的， 能够度量像素的上下文信息，而不能表达地物要素在空间和语义方面的依赖关系，因此在度量不规则功能区时表现较差。2）此外，深度特征缺乏地理意义，可解释性较弱。</li>
<li>➡️ 抛出问题：<font color='red'>如何定义空间模式特征并应用于功能区分割</font></li>
</ul>
</li>
</ul>
</li>
<li>分割方法（基于功能区异质性度量的对象聚合）
<ul>
<li>基于分割依据按照一定规则将图像分割成不同的斑块</li>
<li>基于区域增长的和基于边缘方法</li>
<li>均无法提取功能区， 原因在于他们都为分割提取同质对象而设计的，对象方法侧重低层特征的连续性和同质性；使用区域分割方法，功能区会被分割成破碎的对象，而不是一个整体。</li>
<li>抛出问题：<font color='red'>如何设计功能区分割方法</font></li>
</ul>
</li>
<li>分割尺度（功能区异质性阈值）
<ul>
<li>尺度一个重要的分割参数， 指功能区内部异质性的的最大值。分割尺度的大小将决定分割结果中不同功能区的大小。</li>
<li>现有分割尺度设置方法主要是手工选择一个全局的尺度参数。</li>
<li>抛出问题：<font color='red'>为不同功能区选择局部最优的尺度参数</font></li>
</ul>
</li>
<li>分割结果评价（功能区分割精度计算）
<ul>
<li>需要定量评估功能区分割结果的准确性，验证分割方法的有效性</li>
<li>1）监督评价法需要人工标注功能区边界，人工勾画边界将耗费大量人力物力，不是最佳选择；2）非监督评价假设分割对象内是相似的而分割对象间是有差异的。 但是功能区内部通常是异质的，因此上述假设不适用于功能区分割结果评价。</li>
<li>抛出问题：<font color='red'>需要针对功能区特点研究新的分割评价方法</font></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>第四段：总结
<ul>
<li>本文致力于解决上述四个问题， 自动分割提取功能区的空间单元。</li>
<li>功能区在地理空间上由不同地物要素按一定空间格局组织聚合而成的区域</li>
<li>基本思路为影像特征➡️地物类别➡️功能分区<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210107205617.png" alt="" />
<ul>
<li>首先影像特征提取地物类别（使用传统的面向对象分割和分类方法）</li>
<li>研究地物聚合算法分割提取功能区边界（本章研究重点）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="地理场景-功能区的影像建模方法">地理场景： 功能区的影像建模方法</h4>
<ul>
<li>第一段：强调图像模型
<ul>
<li>难点/根本原因：缺乏一种可数学形式化表达的、可用于建模表达城市功能区的图像模型</li>
</ul>
</li>
<li>第二段：
<ul>
<li>不同社会经济活动导致不同功能区具有不同的<strong>结构或格局</strong>➡️（疑问?️：结构或格局=？建成环境/景观格局）</li>
<li>相同城市功能区内<strong>建成环境</strong>具有相似性，而不同功能区间的建成环境具有差异性➡️</li>
<li><font color='red'>功能区的分割提取问题本质上是建成环境的分割问题</font></li>
<li>需要提出一种<strong>能够表达不同建成环境的图像模型</strong>对建成环境以及功能区进行建模</li>
<li>建成环境的特征体现在<strong>不同地物要素（如建筑物、水体、植被等地物） 的个体特征及其空间分布模式</strong></li>
</ul>
</li>
<li>第三段：
<ul>
<li><font color='red'>地理场景定义为遥感影像上连续且不重叠的区域</font>， 在每个地理场景内，同类型地物应该具有相似的个体特征和空间分布规律。</li>
<li>数学上表达：&hellip;</li>
</ul>
</li>
<li>第四段：地理场景和功能区之间的关系
<ol>
<li>几何属性：均表现为不规则多边形</li>
<li>内部组分：均表现异质性</li>
<li>组成机理：地理场景概念中定义了对象的空间分布格局可表达功能区内部的景观格局或建成环境</li>
<li>分析尺度：均受分析尺度参数的影响</li>
<li>总结：地理场景作为一种图像模型在几何属性、 内部组成、构成机理以及分析尺度四个方面与城市功能区<strong>高度相关</strong>， 因此地理场景能够<strong>有效地</strong>建模和分析城市功能区。</li>
</ol>
</li>
<li>第五段：再次总结：
<ul>
<li>已有的图像分割研究不适用于功能区的分割提取</li>
<li>本章（有一种虎头蛇尾的感jio?）
<ul>
<li>通过定义<strong>空间分布特征</strong>解决分割依据的问题</li>
<li>通过定义<strong>地理场景</strong>这一新的图像模型以及提出<strong>多尺度地理场景分割</strong>解决分割方法和尺度表达两个问题</li>
<li>利用<strong>感兴趣点数据</strong>对分割结果进行评价</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多尺度地理场景分割">多尺度地理场景分割</h3>
<ul>
<li>基础
<ul>
<li>地理场景由多种土地覆盖要素<strong>联合分布</strong>构成</li>
<li>每类土地覆盖要素的个体特征及空间特征之间的<strong>相似性</strong></li>
</ul>
</li>
<li>基本思路：根据土地覆盖类型逐类别进行<strong>分层聚合</strong>，进而将不同层的聚合结果<strong>叠加组合</strong>生成地理场景<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210107213238.png" alt="" />
<ul>
<li>首先， 定义土地覆盖对象的个体特征以及空间分布特征， 其中<u>空间分布特征需要考虑对象与不同类别之间的距离和方向的信息</u>；</li>
<li>然后，基于上述特征的相似度， <u>逐类别聚合土地覆盖对象形成每类对象的对象簇</u>；</li>
<li>最后， 对不同类别对象生成的对象簇进行<u>空间叠加</u>形成最终的地理场景分割结果。</li>
</ul>
</li>
</ul>
<h4 id="空间分布特征">空间分布特征</h4>
<ul>
<li>对象特征
<ul>
<li>光谱、几何、纹理等特征</li>
<li>从视觉的角度表达对象的个体属性，被广泛应用于土地覆盖分类中</li>
<li>缺乏对空间分布特征的描述</li>
</ul>
</li>
<li><strong>空间分布特征</strong>
<ul>
<li>指对象的空间关系、结构和格局等</li>
<li>是探究和发现土地覆盖对象空间分布规律的关键</li>
<li>从<strong>空间邻接和空间分离</strong>两个角度定义和研究空间分布特征
<ul>
<li>空间邻接
<ul>
<li>已有研究采用<u>对象间的公共边长度</u>信息来表达对象的邻接关系</li>
<li>它忽略了周围对象的序列和特征信息，而这些信息对于表征空间分布非常重要</li>
<li>对象邻接关系的三种信息： 邻接对象特征、邻接顺序和邻接边长</li>
</ul>
</li>
<li>空间分离
<ul>
<li>空间分离特征度量每个对象与<u>不相邻的各类对象</u>的空间关系</li>
<li>由每个对象到每个类别的最小距离、平均距离和主要方向组成</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="地理场景分割">地理场景分割</h4>
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210110125358.png" alt="" /></p>
<ol>
<li>聚合：基于这些关系图聚合每类对象形成对象簇，在聚合过程中考虑它们在对象个体特征以及空间分布特征上的相似性。
<ul>
<li>每个地理场景中的同类对象在个体特征和空间模式上应该相似</li>
<li>基于关系图进行空间聚合
<ul>
<li>对象被表达为节点，它们的关系由无向边来表示，只有链接在一起的对象才可以被聚合</li>
<li>链接定义：如果两个对象属于同一类别且?2与?1的重心距离小于20 ?，则这两个对象存在边链接。</li>
<li>聚合算法是基于分形网络演化理论</li>
<li>阈值-地理场景分割尺度</li>
</ul>
</li>
<li>通过聚合，每类土地覆盖对象可以生成许多对象簇， 而这些对象簇空间上是分离的。</li>
</ul>
</li>
<li>扩张：聚合形成的对象簇空间上不连续，将对这些对象簇在空间上进行扩张形成空间上连续的、以某一类对象为主的地理场景。
<ul>
<li>聚合生成<strong>对象簇在空间上不连续</strong>，因为每个类别的对象簇中间有其他类别的对象。地理场景在空间上应该是连续的， 因此提出使用扩张的方法来解决对象簇空间不连续的问题</li>
<li>吸引力模型</li>
</ul>
</li>
<li>空间叠加：多层不同类型的地理场景进行空间叠加， 它们的公共部分作为地理场景分割结果
<ul>
<li>地理场景不是按土地覆盖类别分层表达的，而是包含所有类型的对象</li>
<li>消除、合并破碎的地理场景</li>
<li>考虑其在空间分布特征上的相似性，可以将较小的地理场景合并至相邻的场景中</li>
</ul>
</li>
</ol>
<h4 id="多尺度分割">多尺度分割</h4>
<ul>
<li>现实中城市功能区的大小和异质度可能都不同➡️多尺度</li>
<li>较小尺度生成面积较小且详细的地理场景用于表达相对均质的功能区， 如公园和居民区； 而大尺度生成面积较大且粗略的地理场景用于表达具有高度异质性的城市功能区， 如学校、商业区。</li>
<li>多尺度分割结果组织方式<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210110213016.png" alt="" />
<ul>
<li>层次结构</li>
<li>非层次结构</li>
</ul>
</li>
<li>为了实现层次多尺度分割，<u>最小尺度的地理场景是通过地理场景分割直接生成的，而其他尺度的地理场景是通过聚合小尺度场景生成生成的</u>。</li>
<li>层次结构对于生成多尺度地理场景分割结果效率更高， 而且层次关系对于分析功能区也很重要</li>
</ul>
<h4 id="分割结果评价">分割结果评价</h4>
<ul>
<li><font color='red'>基于兴趣点的功能区分割评价方法</font>：假设每个城市功能区内的 POI 集中于 1-2 类别。因此， <strong>POI 类别单一纯净的功能区分割结果的精度高， 相反如果一个功能区包含许多类 POI，说明分割结果较差精度偏低。</strong> 使用每平方米 POI 信息熵的倒数来定义 POI 的纯净度。（很有道理，但是又觉得哪里不对，或者哪里不严谨?）</li>
<li>??代表分割结果的整体精度</li>
</ul>
<h3 id="实验分析">实验分析</h3>
<h4 id="实验数据">实验数据</h4>
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210110213723.png" alt="" /></p>
<h4 id="多尺度功能区分割提取结果">多尺度功能区分割提取结果</h4>
<ul>
<li>面向对象分析中常用的对象特征<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210110213907.png" alt="" /></li>
<li>流程
<ol>
<li>多尺度分割（MRS）➡️对象</li>
<li>对每个对象提取视觉特征</li>
<li>手工标注训练样本，SVM对象分类</li>
<li>提取对象空间模式特征，尺度缩放至（0，255）</li>
</ol>
</li>
<li>地理场景分割尺度：70、 90、 110、 130 和 150 这五个尺度</li>
<li>子区域分析
<ul>
<li>分割尺度在功能区分割提取中扮演着重要的角色，<strong>不同类型的功能区应使用不同的尺度进行划分</strong>。➡️有必要选择一个<strong>最佳尺度</strong>来<strong>生成最终的功能区分割结果</strong></li>
<li>130尺度</li>
</ul>
</li>
</ul>
<h4 id="空间模式特征在功能区分割中重要性评价">空间模式特征在功能区分割中重要性评价</h4>
<ul>
<li>本实验旨在评估空间格局特征在功能区分割中的重要性，<strong>回答空间格局是否比对象个体特征更重要的问题</strong>。（话术）</li>
<li>结论：
<ul>
<li>空间模式在功能区分割中比对象个体特征更重要，<u>但不能忽略对象个体特征的在功能区分割中的贡献</u>。（话术）</li>
<li>对于整个研究区使用 130 尺度和??? =0.7 可以生成最精确的功能区分割结果</li>
</ul>
</li>
</ul>
<h4 id="功能区分割提取结果">功能区分割提取结果</h4>
<ul>
<li>提取生成了 386 个功能区单元</li>
<li>选取了五个子区域进行目视判读 <img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210110215224.png" alt="" /></li>
</ul>
<h3 id="讨论">讨论</h3>
<h4 id="本章方法与传统的功能区分析对比">本章方法与传统的功能区分析对比</h4>
<ul>
<li>城市功能区分析属于景观生态学、 城市规划学和人文地理研究的范畴，具有广泛的应用前景， 但是还存在许多技术问题</li>
<li>功能区通常具有不同的形状和大小，应该在不同的尺度上进行分析</li>
<li>三个方面与现有的功能区分析有所不同
<ol>
<li>首先，本研究使用多尺度地理场景作为功能区分析的空间单元，而其它研究则使用图像瓦片。<strong>地理场景可以表达任意形状的功能区，既能保持地物对象的完整性，又能保证功能区之间的独立性。</strong></li>
<li>第二， 地理场景的分割尺度指的是地理场景<strong>内部同类对象的异质度</strong>，而图瓦片的尺度则是直接测量其大小。在实际应用中，<strong>多尺度地理场景比多分辨率图像瓦片更适用于多粒度表达和分析城市功能区</strong>。</li>
<li>第三，除了空间单元和分析尺度之外，使用的特征也不同。</li>
</ol>
</li>
</ul>
<h4 id="面向地理场景分析与面向对象分析对比">面向地理场景分析与面向对象分析对比</h4>
<ul>
<li>本研究所提出的基于地理场景的的影像分析（Geoscene-based image analysis,GEOSBIA）旨在通过聚合地理对象（Geographic-object-based image analysis, GEOBIA）来分析功能区。</li>
<li>GEOSBIA 与 GEOBIA 存在显著差异，但它们也有着密切的关系。</li>
</ul>
<h3 id="本章小结">本章小结</h3>
<p>瞧瞧别人的总结能力</p>
<ul>
<li>本章节的<strong>研究成果</strong>可以概述为以下四个方面：
<ol>
<li>提出了表达地物空间格局的特征，并将其用于功能区划分</li>
<li>首次提出了一种多尺度功能区分割提取的方法</li>
<li>讨论了尺度和空间格局权重两个参数对提取城市功能区的影响</li>
<li>利用所提出的方法对北京地区的功能区进行了多尺度提取。</li>
</ol>
</li>
<li>方法应用于北京地区的功能区分割提取获得了以下四个<strong>结论</strong>：
<ol>
<li>首先， 地理场景分割可以在不同尺度上提取不同的城市功能区。</li>
<li>其次，在提取功能区时，空间模式特征比对象的个体特征更重要。</li>
<li>第三， 本章研究方法不同于以往的城市功能区分析， 体现在所使用的空间单元、特征和分析尺度。</li>
<li>第四， 本章提出的地理场景不同于传统单元（如像素和对象），<strong>基于地理场景的图像分析是对传统的基于像素和对象分析的有益补充</strong>，对于高分数据分析而言有重要意义。</li>
</ol>
</li>
</ul>
<h2 id="第三章-自适应尺度学习功能区分割尺度优化">第三章 自适应尺度学习：功能区分割尺度优化</h2>
<h3 id="引言-5">引言</h3>
<ul>
<li>第二章实验发现：功能区具有尺度不确定性 ➡️ 抛出问题：如何自动确定和计算每个功能区的局部最优分割尺度以提高功能区提取精度？</li>
<li><u>已有的分割尺度评价方法都是<strong>从全局的角度</strong>选取一个分割精度最高的尺度作为最优尺度</u>， 但是受功能区异质性的影响，不同功能区的最佳分割尺度通常是不同，<u>因此<strong>最优分割尺度应该是一个局部变量</strong></u>。</li>
<li>本章提出了一种<font color='red'>局部自适应的分割尺度学习方法</font></li>
<li>三类分割现象：欠分割、过分割、正确分割（最优分割）</li>
<li>每个功能区的最优分割尺度受到三个因素影响： 功能区类型、 内部异质性、 与相邻功能区的差异性</li>
<li>根据所使用的尺度，现有的分割方法可以分为三类
<ol>
<li>固定尺度分割
<ul>
<li>包括：基于边缘的、 基于区域的和基于图的分割</li>
<li>全局的、固定的分割尺度对图像进行分割</li>
<li>用户手工指定 ➡️ 分割结果是不准确，很难满足城市功能区提取的要求</li>
</ul>
</li>
<li>多尺度分割
<ul>
<li>考虑了不同类别的功能区， 认为功能区类别是决定分割尺度的关键因素，即<u>每类功能区对于一个最佳分割尺度</u> （第二章）</li>
<li>多尺度分割只能为每个类别选择一个尺度，<u>忽略了功能区个体之间的差异</u></li>
<li>多尺度<u>分割效率很低</u>，因为需要大量人力和计算资源来手动地为不同类别选择最佳的分割尺度</li>
<li>不同的功能区<u>产生于不同的尺度层</u>， 这对于制图和拓扑分析而言是非常不利的</li>
</ul>
</li>
<li>变尺度分割
<ul>
<li>通常使用卷积窗口度量窗口内局部对比度并估计局部分割尺度</li>
<li>忽略了功能区的分类体系；计算局部对比度的窗口大小仍然是全局固定的，手动设置的；</li>
<li>变尺度分割仍然不能做到局部自适应，不能获得准确的分割结果</li>
</ul>
</li>
</ol>
</li>
<li>综上所述，<font color='red'>已有的分割方法</font>主要使用固定尺度、多尺度和可变尺度， 这些尺度没有充分的考虑和建模影响分割尺度的三个因素， <font color='red'>无法实现局部自适应尺度分割</font>， 因此它们获得的<font color='red'>分割结果不够准确无法满足功能区制图应用需求</font>。本章节希望<font color='red'>自动地学习局部自适应分割尺度</font>，并使用自适应尺度<font color='red'>优化多尺度地理场景分割结果</font>，准确提取城市功能区。</li>
</ul>
<h3 id="自适应尺度功能区分割">自适应尺度功能区分割</h3>
<h4 id="自适应分割尺度学习">自适应分割尺度学习</h4>
<ul>
<li>基本思路：利用特征重要性度量尺度重要性， 基于尺度重要性选择局部最优分割尺度
<ol>
<li>首先，在不同的尺度层上分别提取特征；</li>
<li>然后， 使用特征重要性评价方法计算每个特征的局部重要性；</li>
<li>最后， 归算每个尺度层上的特征重要性获得对应尺度的局部重要性，选取重要性最大的尺度作为局部自适应分割尺度。</li>
<li>该研究思路中<strong>最重要的是</strong>构建局部特征重要性评价方法 ➡️ 改进随机森林的特征重要性评价方法</li>
</ol>
</li>
</ul>
<h4 id="自适应尺度约束下功能区分割">自适应尺度约束下功能区分割</h4>
<ul>
<li>采用<strong>层次结构组织</strong>存储多尺度功能区分割结果<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210118103021.png" alt="" /></li>
<li>大尺度功能区与小尺度功能区具有一对多的层次映射关系</li>
<li>最大尺度的功能区分割结果是欠分割的；而最小尺度的分割结果通常是过分割的；最佳的功能区分割尺度应该位于若干个中间尺度层上。</li>
<li><u>将中间尺度内的多尺度分割结果根据自适应尺度学习结果进行重新的排列组合， 形成新的分割结果</u>，最终用于表达自适应分割尺度的功能区提取结果。</li>
<li>自适应分割尺度是<u>逐像素计算的， 即每个像素都被标记了一个自适应尺度</u>。 进而利用最大尺度功能区作为统计单元， <u>统计每个功能区内的自适应尺度的频率分布， 认为出现频率最高的尺度就是该区域功能区分割的最佳尺度</u>。</li>
</ul>
<h3 id="实验分析-1">实验分析</h3>
<h4 id="自适应分割尺度学习结果">自适应分割尺度学习结果</h4>
<ul>
<li>本节选取了 90、110 和 130 三个尺度的分割结果（图 3.6 b-d） 进行自适应尺度学习，利用层次结构组织和存储这三个尺度的分割结果，<strong>对分割结果进行重构</strong>。<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210118104720.png" alt="" /></li>
<li>特征构建：对每个分割结果提取视觉特征以及景观特征
<ul>
<li>视觉特征使用对象视觉特征的频率分布来表示（80维）</li>
<li>景观特征是通过景观格局指数进行度量， 景观格局指数适用于描述景观空间结构的特征， 包括景观破碎度、分离度、 多样性、 分维数和聚集度等（5维度）</li>
<li><strong>而对于每个像素而言，它对应三个多尺度分割块，因此每个像素可以被85 × 3 = 255维特征所描述</strong></li>
</ul>
</li>
<li>学习局部个性尺度<font color='red'>本质上就是利用随机森林分类器计算这 255 维特征对于分类该像素的重要性</font></li>
<li>尺度重要性的空间分布和功能区的局部自适应分割尺度分布结果：<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210118104455.png" alt="" /></li>
<li>每类功能区中各种自适应尺度所占比例结果：<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210118110942.png" alt="" /></li>
</ul>
<h4 id="自适应尺度分割结果">自适应尺度分割结果</h4>
<ul>
<li>最终自适应尺度分割结果是组合了三个不同尺度的分割结果</li>
<li>基于POI的分割精度评价</li>
<li>子区域多尺度分割与自适应分割结果对比</li>
</ul>
<h3 id="讨论-1">讨论</h3>
<ul>
<li>自适应尺度学习方法的优势：
<ol>
<li>首先， 自适应尺度学习仅依赖少量的训练样本， 就可以从多尺度分割结果中学习到局部自适应的尺度，学习过程是数据驱动的，而监督样本是知识驱动的。</li>
<li>其次，自适应尺度是一个局部变量，能够根据局部建筑环境的变化进行自动调整。</li>
<li>第三，自适应尺度学习过程中充分考虑了多尺度特征信息。</li>
<li>第四， 除了功能区分割制图以外，自适应尺度还有可能应用于其它领域， 比如城市调查（温度、污染、人口、犯罪和经济的空间分布）。这些调查都需要在合适的尺度上进行， 已有的城市调查方法常常是基于街区等固定尺度来进行的，因此忽略了调查变量的尺度效应以及空间非平稳性， 这使得调查结果不可靠。因此， 在城市调查中需要使用自适应尺度。例如， 在调查城市地表温度时， 应使用自适应尺度分割结果作为空间单元进行地表温度反演。</li>
</ol>
</li>
</ul>
<h3 id="本章小结conclusion模板">本章小结（Conclusion模板）</h3>
<p>[这里也体现了Conclusion和Abstract的不同]</p>
<ul>
<li>问题：尺度不确定性</li>
<li>已有的分割尺度分析方法：全局角度</li>
<li>本文（本章）：旨在提出一种自适应尺度分割方法</li>
<li>重要结论：
<ol>
<li>首先， 不同功能区的最佳分割尺度是不同的， 其受功能区类别、与周围环境对比度以及内部异质度的影响。</li>
<li>其次，自适应尺度分割解决了城市功能区分割提取中跨尺度的问题，其结果优于多尺度分割结果。</li>
</ol>
</li>
<li>重要贡献：
<ol>
<li>提出了自适应分割尺度学习方法， 该方法充分建模分析了影响分割尺度的三个因素;</li>
<li>提出了自适应尺度约束下的分割优化算法， 并将该方法用于分割提取北京地区的功能区。</li>
</ol>
</li>
<li>贡献总结：<font color='red'>根据已有工作检索结果发现</font>本章<strong>首次实现了</strong>高分影像的自适应尺度学习及分割优化方法， 解决了地物分割提取中跨尺度的问题，推动了高分影像分割技术的发展。</li>
<li>尽管自适应尺度在功能区分割中表现良好，但仍有一些问题有待进一步研究。</li>
</ul>
<h2 id="第四章-空间语义共生概率模型功能区空间格局特征表达">第四章 空间语义共生概率模型：功能区空间格局特征表达</h2>
<ul>
<li>特征度量与表达是功能区分析的基础，因此如何提取有效的功能区特征是本章研究的重点。</li>
<li>传统的图像视觉特征难以充分表达城市功能区， 而空间格局特征是表达功能区的关键。空间格局特征的提取和计算结果不稳定， 易受仿射变换影响。</li>
<li>充分考虑功能区的综合性和异质性，研究并提取更加鲁棒的空间格局特征对城市功能区进行表达。</li>
</ul>
<h3 id="引言-6">引言</h3>
<ul>
<li>从计算机视觉的角度来看，遥感影像中的城市功能区可以通过不同的特征进行表达， 如视觉特征、抽象特征、语义特征
<ul>
<li>视觉特征</li>
<li>抽象特征</li>
<li>语义特征</li>
</ul>
</li>
<li>上述这些特征不适用于表达功能区的本质原因是，这些特征都是从计算机视觉角度定义的、 用于表达图像场景的， 但是图像场景和功能区影像是有明显差异的： 功能区是有明确的地理学、景观生态学含义的，其影像能够体现出不同的建成环境， 而图像场景是缺乏明确定义的，一般来说任何一个图像块都可以成为图像场景</li>
<li>作为城市功能区的基本组成部分，对象及其空间格局是功能区分析的基础</li>
<li>对象的空间关系包括不同对象之间的距离关系和方向关系。度量对象的空间关系常受三个问题的影响，包括各向异性、尺度依赖性和语义依赖性。对象的空间关系度量可能受三个因素的影响： <strong>方向、距离、对象语义</strong>， 因此在度量空间关系时应充分考虑这三个因素</li>
<li>综上所述（学习叙事逻辑）
<ul>
<li><strong>已有的</strong>关于城市功能区特征表达的研究工作大多忽略了对象的空间格局信息，因此难以获得准确的表达功能区和获取高精度的功能区分析结果； <strong>近期一些研究</strong>已经注意到对象空间信息对于功能区影像分析的重要性， 但是它们忽略了对象空间信息度量中存在的三个重要问题（即各向异性、尺度依赖性和语义依赖性）。</li>
<li><strong>本研究</strong>考虑了这三个特性，并通过度量对象在空间上和语义上的共生关系来表达功能区的空间格局进而对城市功能区进行特征表达。</li>
<li><strong>为实现这个目标， 需要回答两个问题</strong>： 第一， 如何度量对象的空间格局？ 第二， 如何利用空间格局对城市功能区进行分类？</li>
<li>因此， <strong>本章提出了</strong>一种新的功能区空间语义特征用于表达功能区内部地物的空间格局，然后将其与分类器结合实现城市功能区分类识别。</li>
</ul>
</li>
</ul>
<h3 id="地理对象的空间语义共生分析">地理对象的空间语义共生分析</h3>
<ul>
<li>基本思路是以对象类别语义为基础，度量不同对象之间在不同方向和不同距离上的共生概率，然后对不同方向和距离上的共生概率做二次卷积获得空间语义共生概率密度函数。</li>
</ul>
<h3 id="实验分析-2">实验分析</h3>
<p>先使用公共数据集进行场景分类，再使用北京的数据进行功能区分类</p>
<h4 id="第一部分使用公共数据集将本章所提出的空间语义特征与其它场景特征进行对比">第一部分：使用公共数据集，将本章所提出的空间语义特征与其它场景特征进行对比</h4>
<ul>
<li>公共数据集：<a href="http://weegee.vision.ucmerced.edu/datasets/landuse.html">UC Merced Land Use Dataset</a>。 包括 21 个土地利用类型，每类有 100幅图像（256× 256 像素）。</li>
<li>主要实验步骤：对象识别和土地利用场景分类<img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210201162226.png" alt="" />
<ul>
<li>对象识别：首先利用 multiresolution segmentation（MRS; Baatz 和 Schäpe, 2000） 分割方法将每个图像根据颜色分割成不同的对象。然后，提取图像对象特征包括光谱特征、纹理特征和几何特征（表 2.1）。最后，利用支持向量机分类器（Suykens 和Vandewalle, 1999）将这些对象分为阴影、水体、 植被、土壤、建筑物、道路、船舶、车辆、飞机等 9 类。</li>
<li>功能区分类：提取 SSCP 作为空间语义特征对每个图像场景进行数字化表达，在特征表达的基础上使用 semi-latent Dirichlet allocation（S-LDA; Wang, Sabzmeydani 和 Mori, 2007）监督分类器对 21 类图像场景进行分类，其中随机选择 80%图像场景作为训练样本，而另外 20%则用作测试样本。此实验使用<u>五次交叉验证方法</u>对分类结果进行评价（表 4.1），并使用<u>平均生产者精度</u>（每类正确分类个数与测试样本数的比值）来衡量每个类别的分类精度。➡️ 精度高达97.6%</li>
<li>与前人方法比较</li>
</ul>
</li>
</ul>
<h4 id="第二部分北京地区功能区表达与识别">第二部分：北京地区功能区表达与识别</h4>
<ul>
<li>分类：商业区、 居民区、工业区、学校、公园、城中村。</li>
<li>为了对表达和识别这些功能区，本实验分为以下四个步骤： 首先用道路网数据将高分遥感影像分割成不同的功能区。结果，生成 254 个具有不同形状和大小的功能区单元。然后，用 MRS对每个功能区中的对象进行分割，并用支持向量机对这些对象进行土地覆盖分类，共提取了七类土地覆盖对象，包括阴影、植被、土壤、水体、建筑物、工厂和道路。接着，提出的空间语义共生分析方法对每个功能区提取了 SSCP 特征。最后，使用 S-LDA 算法对城市功能区进行分类。 <img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210201163136.png" alt="" /></li>
<li>根据城市规划图和实地调查结果，人工选取了** 63 个功能区作为训练样本**。这些样本用于训练 S-LDA 分类器， 进而将其他 191 个未标注样本划分为不同的类别。为了定量地评价此分类结果， 基于百度地图以及高德地图对分类中的 **191 个功能区进行人工分类和手动标注**。 这里将人工识别结果作为测试样本，对功能区分类结果进行精度评估。</li>
</ul>
<h3 id="讨论-2">讨论</h3>
<ul>
<li>哪些对象的空间关系在表达功能区中更为有效：<strong>Relief 算法</strong><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20210201164000.png" alt="" /></li>
<li>SSCP 的三个重要的特性</li>
<li>SSCP 与其它空间特征的对比</li>
<li>SSCP 特征的优缺点</li>
</ul>
<h3 id="本章小结-1">本章小结</h3>
<h2 id="第五章-层次语义认知模型-功能区多源特征层次依赖性表达">第五章 层次语义认知模型： 功能区多源特征层次依赖性表达</h2>
<ul>
<li>单一特征难以全面地、 充分地表达功能区，因此需要组合多源特征对功能区进行表达</li>
<li>在组合这些多源异构特征时，发现这些特征之间具有很强的层次依赖关系： 视觉特征是获取对象语义特征的基础，而对象语义特征是获取空间格局特征的基础。</li>
<li>本章研究层次语义认知模型， 在多个层次上（纵向上） 对城市功能区进行特征表达，并且建模多源特征之间的层次依赖关系。</li>
</ul>
<p><u></u><br />
<font color='red'></font></p>
<hr />
<p><img src="https://cdn.jsdelivr.net/gh/xunhs/image_host@master/PicX/20201110165741.jpg" alt="" /></p>
    </article>
    
    
<script defer src="/js/clipboard.min.1626706afc88d95ebe1173b553ec732c6dc82a576989315fdf5e7779af738a44.js"></script>

<script defer src="/js/helper/prev.min.js"></script>

<script defer src="/js/helper/prop.min.js"></script>
<script>
  'use strict';
  document.addEventListener('DOMContentLoaded', function () {
    
    var clipInit = false;
    var preChromaElem = document.querySelectorAll('pre.chroma');
    var langCodeElem = document.querySelectorAll('.language-code');
    var dollarCodeElem = document.querySelectorAll('div.language-\\$');
    var gtCodeElem = document.querySelectorAll('div.language-\\>');

    var makeClipboard = function(elem) {
      var code = elem,
          text = elem.textContent;
        
      if (text.length > 15) {
        if (!clipInit) {
          var text, clip = new ClipboardJS('.copy-to-clipboard', {
            text: function (trigger) {
              var codeElem = prev(trigger).querySelectorAll('code');
              if (codeElem.length > 1) {
                text = prev(trigger).querySelector('code[class^="language-"]').textContent;
              } else {
                text = prev(trigger).querySelector('code').textContent;
              }

              return text.replace(/^\$\s/gm, '');
            }
          });

          var inPre;
          clip.on('success', function (e) {
            e.clearSelection();
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', 'Copied to clipboard!');
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clip.on('error', function (e) {
            inPre = prop(e.trigger.parentNode, 'tagName') == 'PRE';
            e.trigger.setAttribute('aria-label', e.action.toString());
            e.trigger.classList.add('tooltipped');
            e.trigger.classList.add('tooltipped-w');
          });

          clipInit = true;
        }

        var notAllowedClass = ['language-mermaid', 'language-viz', 'language-wave', 'language-chart', 'language-msc', 'language-flowchart'];
        var isNotAllowedIncluded = false;
        var curClassName = code.getAttribute('class');

        for (var i = 0; i < notAllowedClass.length; i++) {
          if (curClassName && curClassName.startsWith(notAllowedClass[i])) {
            isNotAllowedIncluded = true;
            break;
          }
        }

        if (!isNotAllowedIncluded) {
          if (curClassName) {
            var newClipboardElem = document.createElement('span');
            newClipboardElem.setAttribute('class', 'copy-to-clipboard');
            newClipboardElem.setAttribute('title', 'Copy to clipboard');
            elem.parentNode.parentNode.insertBefore(newClipboardElem, elem.parentNode.nextElementSibling);
          }
        }
      }
    }

    var makeSymbolClipboard = function(elem) {
      var clipboardSpan = document.createElement('span');
      clipboardSpan.setAttribute('class', 'copy-to-clipboard');
      clipboardSpan.setAttribute('title', 'Copy to clipboard');
      elem.parentNode.parentNode.insertBefore(clipboardSpan, elem.parentNode.nextElementSibling);
    }

    preChromaElem ? 
    preChromaElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function(codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;
    
    langCodeElem ? 
    langCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeClipboard(codeElem);
      });
    }) : null;

    dollarCodeElem ? 
    dollarCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;

    gtCodeElem ?
    gtCodeElem.forEach(function(elem) {
      elem.querySelectorAll('code').forEach(function (codeElem) {
        makeSymbolClipboard(codeElem);
      });
    }) : null;
    
  });
</script>
    <script>
  'use strict';
  
  function wrap(el, wrapper) {
    el.parentNode.insertBefore(wrapper, el);
    wrapper.appendChild(el);
  }

  (function () {
    var singleContentsElem = document.querySelector('.single__contents');
    singleContentsElem ? 
    singleContentsElem.querySelectorAll('pre > code').forEach(function(elem) {
      var dataLang = elem.getAttribute('data-lang');
      var dataLangWrapper = document.createElement('div');
      var code = null;
      var codeTitle = null;

      if (dataLang && dataLang.includes(':')) {
        code = dataLang.split(':')[0];
        codeTitle = dataLang.split(':')[1];

        dataLangWrapper.className = 'language-' + code;
        dataLangWrapper.setAttribute('data-lang', codeTitle);

        elem.className = 'language-' + code;
        elem.setAttribute('data-lang', codeTitle);
        elem.setAttribute('id', codeTitle);
      } else if (!dataLang) {
        dataLangWrapper.setAttribute('data-lang', 'Code');
        dataLangWrapper.className = 'language-code';
      }

      if (!dataLang || codeTitle) {
        wrap(elem.parentNode, dataLangWrapper);
      }

    }) : null;
  })();

  var langCodeElem = document.querySelectorAll('.language-code');
  langCodeElem ? langCodeElem.forEach(function (elem) {
    var newElem = document.createElement('span');
    newElem.className = 'copy-to-clipboard';
    newElem.setAttribute('title', 'Copy to clipboard');
    elem.append(newElem);
  }) : null;
  

  

  
  var dollarCodeElem = document.querySelectorAll('div.language-\\$');
  var gtCodeElem = document.querySelectorAll('div.language-\\>');

  dollarCodeElem ?
  dollarCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '$<br/>';
    }) : null;
  }) : null;

  gtCodeElem ?
  gtCodeElem.forEach(function(elem) {
    var lnts = elem.parentNode.parentNode ? elem.parentNode.parentNode.querySelectorAll('.lnt') : null;
    lnts ? 
    lnts.forEach(function(lnt) {
      lnt.innerHTML = '><br/>';
    }) : null;
  }) : null;
  
</script>
    
<div class="donation">
  <div class="donation__message">
    Share on
  </div>
  <div class="donation__icons">
    
    
    
      
    
      
    
  </div>
</div>


    
    
<div class="whoami__gutter"></div>
<hr class="hr-slash whoami-hr"/>
<section class="whoami">
  <div class="whoami__image-wrapper">
    
    
      
        <img data-src="/images/whoami/avatar.jpg" src="data:image/svg+xml,%0A%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24'%3E%3Cpath fill='none' d='M0 0h24v24H0V0z'/%3E%3Cpath fill='%23aaa' d='M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-1 16H6c-.55 0-1-.45-1-1V6c0-.55.45-1 1-1h12c.55 0 1 .45 1 1v12c0 .55-.45 1-1 1zm-4.44-6.19l-2.35 3.02-1.56-1.88c-.2-.25-.58-.24-.78.01l-1.74 2.23c-.26.33-.02.81.39.81h8.98c.41 0 .65-.47.4-.8l-2.55-3.39c-.19-.26-.59-.26-.79 0z'/%3E%3C/svg%3E" alt="Ethan" class="lazyload whoami__image"/>
      
    
  </div>
  <div class="whoami__contents">
    <div class="whoami__written-by">
      WRITTEN BY
    </div>
    <div class="whoami__title">
      
        Ethan
      
    </div>
    <div class="whoami__desc">
      
        Magician
      
    </div>
    <div class="whoami__social">
      
      
      
      
      
      
      
      
      <a href="mailto:gishusheng@outlook.com" title="email" aria-label="email">
        <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-.4 4.25l-7.07 4.42c-.32.2-.74.2-1.06 0L4.4 8.25c-.25-.16-.4-.43-.4-.72 0-.67.73-1.07 1.3-.72L12 11l6.7-4.19c.57-.35 1.3.05 1.3.72 0 .29-.15.56-.4.72z"/></svg>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</section>
<hr class="hr-slash whoami-hr" />


    <section class="related">
    
    
    <h1 class="related__title">
      <hr class="hr-dots"/>
      <div>
        See Also
      </div>
      <hr class="hr-dots"/>
    </h1>
    <ul class="related-ul">
        
        <li>
          <a href="/posts/n/2020-07-16-%E5%8D%9A%E5%A3%AB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%9C%AD%E8%AE%B0-2/" class="related__link">博士论文阅读札记(2)</a>
        </li>
        
        <li>
          <a href="/posts/n/2020-06-21-%E5%8D%9A%E5%A3%AB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E6%9C%AD%E8%AE%B0-1/" class="related__link">博士论文阅读札记-1</a>
        </li>
        
        <li>
          <a href="/posts/n/93/" class="related__link">刘建平博客NLP-阅读笔记</a>
        </li>
        
    </ul>
    
  </section>
    <div class="grow"></div>
<nav class="pagination-single">
  
    
      <a href="https://www.xunhs.cyou/posts/j/2020-11-01-2020-11/" class="pagination-single__left">
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z"/></svg>
        </div>
        <div class="pagination-single__left-title">2020-11</div>      
      </a>
    
    <div class="grow"></div>
    
      <a href="https://www.xunhs.cyou/2020/11/30/108/" class="pagination-single__right">      
        <div class="pagination-single__right-title">相机操作入门指南-索尼</div>
        <div class="pagination-single__icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M5 13h11.17l-4.88 4.88c-.39.39-.39 1.03 0 1.42.39.39 1.02.39 1.41 0l6.59-6.59c.39-.39.39-1.02 0-1.41l-6.58-6.6c-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41L16.17 11H5c-.55 0-1 .45-1 1s.45 1 1 1z"/></svg>
        </div>
      </a>
    
  
</nav>
    
    <div class="modal micromodal-slide" id="modal" aria-hidden="true">
  <div class="modal__overlay" tabindex="-1" data-micromodal-close>
    <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-title">
      
      <div class="modal__content" id="modal-content">
        <div id="mySwipe" class="swipe">
          <div class="swipe-wrap">
          </div>
        </div>
      </div>

      <span class="modal__items">
        
        <span class="modal__header">
          <div class="modal__paging" title="Page Info" aria-label="Current Page">
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--close" title="Close" aria-label="Close Button" data-micromodal-close>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="25" height="25"><path fill="currentColor" d="M 21.734375 19.640625 L 19.636719 21.734375 C 19.253906 22.121094 18.628906 22.121094 18.242188 21.734375 L 13 16.496094 L 7.761719 21.734375 C 7.375 22.121094 6.746094 22.121094 6.363281 21.734375 L 4.265625 19.640625 C 3.878906 19.253906 3.878906 18.628906 4.265625 18.242188 L 9.503906 13 L 4.265625 7.761719 C 3.882813 7.371094 3.882813 6.742188 4.265625 6.363281 L 6.363281 4.265625 C 6.746094 3.878906 7.375 3.878906 7.761719 4.265625 L 13 9.507813 L 18.242188 4.265625 C 18.628906 3.878906 19.257813 3.878906 19.636719 4.265625 L 21.734375 6.359375 C 22.121094 6.746094 22.121094 7.375 21.738281 7.761719 L 16.496094 13 L 21.734375 18.242188 C 22.121094 18.628906 22.121094 19.253906 21.734375 19.640625 Z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--full" title="Full Screen" aria-label="Full Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="25" height="25"><path fill="currentColor" d="M 5 3 C 3.9069372 3 3 3.9069372 3 5 L 3 8 A 1.0001 1.0001 0 1 0 5 8 L 5 5 L 8 5 A 1.0001 1.0001 0 1 0 8 3 L 5 3 z M 16 3 A 1.0001 1.0001 0 1 0 16 5 L 19 5 L 19 8 A 1.0001 1.0001 0 1 0 21 8 L 21 5 C 21 3.9069372 20.093063 3 19 3 L 16 3 z M 3.984375 14.986328 A 1.0001 1.0001 0 0 0 3 16 L 3 19 C 3 20.093063 3.9069372 21 5 21 L 8 21 A 1.0001 1.0001 0 1 0 8 19 L 5 19 L 5 16 A 1.0001 1.0001 0 0 0 3.984375 14.986328 z M 19.984375 14.986328 A 1.0001 1.0001 0 0 0 19 16 L 19 19 L 16 19 A 1.0001 1.0001 0 1 0 16 21 L 19 21 C 20.093063 21 21 20.093063 21 19 L 21 16 A 1.0001 1.0001 0 0 0 19.984375 14.986328 z"/></svg>
          </div>
          <div class="modal__icon modal__toolbar modal__toolbar--normal" title="Normal Screen" aria-label="Normal Screen Button">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="25" height="25"><path fill="currentColor" d="M 16.96875 4.972656 C 15.867188 4.988281 14.984375 5.894531 15 7 L 15 15 L 7 15 C 6.277344 14.988281 5.609375 15.367188 5.246094 15.992188 C 4.878906 16.613281 4.878906 17.386719 5.246094 18.007813 C 5.609375 18.632813 6.277344 19.011719 7 19 L 19 19 L 19 7 C 19.007813 6.460938 18.796875 5.941406 18.414063 5.558594 C 18.03125 5.175781 17.511719 4.964844 16.96875 4.972656 Z M 32.96875 4.972656 C 31.921875 4.988281 31.0625 5.8125 31.003906 6.859375 C 31 6.90625 31 6.953125 31 7 L 31 19 L 43 19 C 43.066406 19 43.132813 19 43.199219 18.992188 C 44.269531 18.894531 45.070313 17.972656 45.015625 16.902344 C 44.964844 15.828125 44.074219 14.988281 43 15 L 35 15 L 35 7 C 35.007813 6.460938 34.796875 5.941406 34.414063 5.558594 C 34.03125 5.175781 33.511719 4.964844 32.96875 4.972656 Z M 7 31 C 6.277344 30.988281 5.609375 31.367188 5.246094 31.992188 C 4.878906 32.613281 4.878906 33.386719 5.246094 34.007813 C 5.609375 34.632813 6.277344 35.011719 7 35 L 15 35 L 15 43 C 14.988281 43.722656 15.367188 44.390625 15.992188 44.753906 C 16.613281 45.121094 17.386719 45.121094 18.007813 44.753906 C 18.632813 44.390625 19.011719 43.722656 19 43 L 19 31 Z M 31 31 L 31 43 C 30.988281 43.722656 31.367188 44.390625 31.992188 44.753906 C 32.613281 45.121094 33.386719 45.121094 34.007813 44.753906 C 34.632813 44.390625 35.011719 43.722656 35 43 L 35 35 L 43 35 C 43.722656 35.011719 44.390625 34.632813 44.753906 34.007813 C 45.121094 33.386719 45.121094 32.613281 44.753906 31.992188 C 44.390625 31.367188 43.722656 30.988281 43 31 Z"/></svg>
          </div>
        </span>
        
        <div class="modal__icon modal__arrow modal__arrow--left" title="Arrow Left" aria-label="Arrow Left Button">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 23.28125 11 L 10 10 L 10 6.851563 C 10 6.523438 9.839844 6.277344 9.519531 6.03125 C 9.199219 5.949219 8.878906 5.949219 8.640625 6.113281 C 5.359375 8.410156 2.238281 12.257813 2.160156 12.421875 C 2.082031 12.578125 2.007813 12.8125 2.003906 12.976563 C 2.003906 12.980469 2 12.988281 2 12.992188 C 2 13.15625 2.078125 13.402344 2.160156 13.484375 C 2.238281 13.648438 5.28125 17.507813 8.640625 19.804688 C 8.960938 19.96875 9.28125 20.050781 9.519531 19.886719 C 9.839844 19.722656 10 19.476563 10 19.148438 L 10 16 L 23.28125 15 C 23.679688 14.679688 24 13.875 24 12.992188 C 24 12.195313 23.761719 11.320313 23.28125 11 Z"/></svg>
        </div>
        
        <div class="modal__icon modal__arrow modal__arrow--right" title="Arrow Right" aria-label="Arrow Right Button">

          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="28" height="28"><path fill="currentColor" d="M 2.71875 11.023438 L 16 10.023438 L 16 6.875 C 16 6.546875 16.160156 6.300781 16.480469 6.054688 C 16.800781 5.972656 17.121094 5.972656 17.359375 6.136719 C 20.640625 8.433594 23.761719 12.28125 23.839844 12.445313 C 23.917969 12.601563 23.992188 12.835938 23.996094 13 C 23.996094 13.003906 24 13.011719 24 13.015625 C 24 13.179688 23.921875 13.425781 23.839844 13.507813 C 23.761719 13.671875 20.71875 17.53125 17.359375 19.828125 C 17.039063 19.992188 16.71875 20.074219 16.480469 19.910156 C 16.160156 19.746094 16 19.5 16 19.171875 L 16 16.023438 L 2.71875 15.023438 C 2.320313 14.703125 2 13.898438 2 13.015625 C 2 12.21875 2.238281 11.34375 2.71875 11.023438 Z"/></svg>
        </div>

        <div class="modal__caption">
          <div class="modal__caption--text">
          </div>
        </div>

      </span>
    </div>
  </div>
</div>


<script defer src="/js/swipe.min.989e074dfb92ce7f57a92c1df7027f88b53c50a54fd9ad450a673a64aa91bfa4.js"></script>

<script defer src="/js/micromodal.min.de01b44b2f383056bbcaf6ee921fd385d79108ec1129afd0eb2f3f5a07e11f45.js"></script>

<script defer src="/js/helper/fadeinout.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  
   
  var docElem = document.documentElement;

   
  function openFullscreen() {
    if (docElem.requestFullscreen) {
      docElem.requestFullscreen();
    } else if (docElem.mozRequestFullScreen) {  
      docElem.mozRequestFullScreen();
    } else if (docElem.webkitRequestFullscreen) {  
      docElem.webkitRequestFullscreen();
    } else if (docElem.msRequestFullscreen) {  
      docElem.msRequestFullscreen();
    }
  }

   
  function closeFullscreen() {
    if (document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {  
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {  
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {  
        document.msExitFullscreen();
      }
    }
  }

  var modal = document.getElementById('modal');
  var galleryContainerElem = document.querySelector('.gallery__container');
  var swipeWrapElem = document.querySelector('.swipe-wrap');
  var mySwipeElem = document.getElementById('mySwipe');
  var arrowLeftElem = document.querySelector('.modal__arrow--left');
  var arrowRightElem = document.querySelector('.modal__arrow--right');
  var closeElem = document.querySelector('.modal__toolbar--close');
  var fullElem = document.querySelector('.modal__toolbar--full');
  var normalElem = document.querySelector('.modal__toolbar--normal');
  var captionElem = document.querySelector('.modal__caption');
  var pagingElem = document.querySelector('.modal__paging');
  var itemsElem = document.querySelector('.modal__items');
  var imgTotalNum = null;
  var myFadeTimeout = null;
  var mySwipe = null;
  var keydownFunction = function (e) {
    if (e.key === 'ArrowRight') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.next();
      }
    } else if (e.key === 'ArrowLeft') {
      if (modal && modal.classList.contains('is-open')) {
        mySwipe.prev();
      }
    }
  }

  if (galleryContainerElem) {
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  } else {
    galleryContainerElem = document.querySelector('.single__contents');
    imgTotalNum = galleryContainerElem.querySelectorAll('img').length;
  }

  MicroModal.init({
    onClose: function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
        closeFullscreen();
      }
      window.removeEventListener('keydown', keydownFunction);
    },
    disableScroll: true,
    disableFocus: true,
    awaitOpenAnimation: false,
    awaitCloseAnimation: false,
    debugMode: false,
  });

  var imageLoad = function(src) {
    return new Promise(function(resolve, reject) {
      var newImg = new Image;
      newImg.onload = function() {
        resolve(newImg);
      }
      newImg.onerror = reject;
      newImg.src = src;
    });
  }

  galleryContainerElem.querySelectorAll('img').forEach(function (elem, idx) {
    elem.style.cursor = 'pointer';

    var clonedElem = elem.cloneNode(true);
    clonedElem.style.maxHeight = '100%';
    clonedElem.style.maxWidth = '100%';
    clonedElem.onclick = function (e) {
      e.stopPropagation();
    }

    var wrapper = document.createElement('div');
    wrapper.style.width = '100%';
    wrapper.style.height = '100vh';
    wrapper.setAttribute('data-micromodal-close', '');
    wrapper.onclick = function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
    }
    wrapper.onmouseenter = function () {
      clearTimeout(myFadeTimeout);
      fadeIn(itemsElem, 200);
    };
    wrapper.onmouseleave = function () {
      myFadeTimeout = setTimeout(function () {
        fadeOut(itemsElem, 200);
      }, 2500);
    }
    wrapper.ontouchstart = function() {
      fadeIn(itemsElem, 200);
    }
    wrapper.append(clonedElem);
    swipeWrapElem.append(wrapper);

    elem.addEventListener('click', async function (e) {
      MicroModal.show('modal');
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }

      var imgSrc = e.target.getAttribute('data-src') || e.target.getAttribute('src');
      var img = await imageLoad(imgSrc);
      clonedElem.style.width = img.width + 'px';
      clonedElem.style.height = img.height + 'px';
      
      
      mySwipe = new Swipe(mySwipeElem, {
        startSlide: idx,
        draggable: true,
        autoRestart: false,
        continuous: false,
        disableScroll: true,
        stopPropagation: true,
        callback: async function (index, element) {
          
          var imgElem = element.querySelector('img');
          var imgSrc = imgElem.getAttribute('data-src') || imgElem.getAttribute('src');
          var img = await imageLoad(imgSrc);
          imgElem.style.width = img.width + 'px';
          imgElem.style.height = img.height + 'px';

          
          if (captionElem && imgElem) {
            var caption = null;
            if (imgElem.getAttribute('data-caption')) {
              caption = imgElem.getAttribute('data-caption');
            } else if (imgElem.getAttribute('title')) {
              caption = imgElem.getAttribute('title');
            } else if (imgElem.getAttribute('alt')) {
              caption = imgElem.getAttribute('alt');
            } else {
              caption = imgElem.getAttribute('src');
            }

            captionElem.querySelector('.modal__caption--text').innerText = caption;
            pagingElem.innerText = (index + 1) + ' / ' + imgTotalNum;

            clearTimeout(myFadeTimeout);
            fadeIn(itemsElem, 200);
          }
        },
      });

      fadeIn(itemsElem);

      
      if (captionElem) {
        var caption = null;
        if (e.target.getAttribute('data-caption')) {
          caption = e.target.getAttribute('data-caption');
        } else if (e.target.getAttribute('title')) {
          caption = e.target.getAttribute('title');
        } else if (e.target.getAttribute('alt')) {
          caption = e.target.getAttribute('alt');
        } else {
          caption = e.target.getAttribute('src');
        }

        captionElem.querySelector('.modal__caption--text').innerText = caption;
        pagingElem.innerText = (idx + 1) + ' / ' + imgTotalNum;
      }

      if (normalElem && fullElem) {
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
      }
    });

    window.addEventListener('keydown', keydownFunction);
  });

  arrowLeftElem ?
    arrowLeftElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.prev();
      }
    }) : null;
  arrowRightElem ?
    arrowRightElem.addEventListener('click', function (e) {
      if (mySwipe) {
        mySwipe.next();
      }
    }) : null;

  closeElem ?
    closeElem.addEventListener('click', function () {
      if (mySwipe) {
        mySwipe.kill();
        mySwipe = null;
      }
      closeFullscreen();
      MicroModal.close('modal');
    }) : null;

  fullElem ?
    fullElem.addEventListener('click', function (e) {
      openFullscreen();
      if (normalElem) {
        normalElem.style.zIndex = 25;
        normalElem.style.opacity = 1;
        fullElem.style.zIndex = -1;
        fullElem.style.opacity = 0;
      }
    }) : null;

  normalElem ?
    normalElem.addEventListener('click', function (e) {
      closeFullscreen();
      if (fullElem) {
        fullElem.style.zIndex = 25;
        fullElem.style.opacity = 1;
        normalElem.style.zIndex = -1;
        normalElem.style.opacity = 0;
      }
    }) : null;
  
});
</script>

    <div class="hide">
      
    </div>
  </div>
</main>


<script>
  
  
  

  var enableToc = JSON.parse("true");
  var toc = JSON.parse("null");
  var tocPosition = JSON.parse("\"outer\"");
  
  var singleMainElem = document.querySelector('.single__main');
  var singleSideElem = document.querySelector('.single__side');

  enquire.register("screen and (max-width: 769px)", {
    match: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        if (singleMainElem && singleSideElem) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
          singleSideElem.classList.remove('main-side');
          singleSideElem.classList.add('hide');
        }
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }
    },
    unmatch: function () {
      if ((enableToc || toc) && tocPosition !== "outer") {
        singleMainElem.classList.remove('main');
        singleMainElem.classList.add('main-main');
        singleSideElem.classList.remove('hide');
        singleSideElem.classList.add('main-side');
      } else if (tocPosition === "outer") {
        if (singleMainElem && !singleMainElem.classList.contains('main-main')) {
          singleMainElem.classList.remove('main-main');
          singleMainElem.classList.add('main');
        }
        if (singleSideElem && !singleSideElem.classList.contains('hide')) {
          singleSideElem.classList.add('hide');
        }
      }

      var navCollapseBtn = document.querySelector('.navbar__burger');
      var navCollapse = document.getElementsByClassName('navbarm__collapse')[0];
      if (navCollapse) {
        navCollapse.setAttribute('data-open', false);
        navCollapse.style.maxHeight = 0;
        navCollapseBtn.classList.remove('is-active');
      }
      document.getElementsByClassName('navbar__menu')[0].classList.remove('is-active');
      document.getElementsByClassName('mobile-search')[0].classList.add('hide');
    },
    setup: function () { },
    deferSetup: true,
    destroy: function () { },
  });
</script>





<script defer src="/js/helper/getParents.min.js"></script>

<script defer src="/js/helper/closest.min.js"></script>

<script defer src="/js/helper/prev.min.js"></script>

<script defer src="/js/helper/prop.min.js"></script>

<script defer src="/js/helper/fadeinout.min.js"></script>

<script defer src="/js/helper/throttle.min.js"></script>



















































<script>
  'use strict';

  window.onload = function() {
    var navbar = document.querySelector('.navbar');
    var singleContentsElem = document.querySelector('.single__contents');

    
    
    
    var enableBusuanzi = JSON.parse("false");
    var busuanziPagePV = JSON.parse("true");
    
    if (enableBusuanzi && busuanziPagePV) {
      var pagePvElem = document.querySelector('#busuanzi_value_page_pv');
      pagePvElem.textContent = pagePvElem.textContent.replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,");
    }    
    



    
    
    
    
    
    
    var enableToc = JSON.parse("true");
    var toc = JSON.parse("null");
    var hideToc = JSON.parse("false");
    var tocFlexbox = document.querySelector('.toc__flexbox');
    var tocFlexboxOuter = document.querySelector('.toc__flexbox--outer');
    var tocFolding = JSON.parse("true");
    
    if ((enableToc || toc) && document.querySelector('.toc')) {
      var tableOfContentsElem = document.querySelector('.toc').querySelector('#TableOfContents');

      tableOfContentsElem.onmouseenter = function() {
        if (navbar.classList.contains('scrolling')) {
          navbar.classList.remove('scrolling');
        }
      }

      tableOfContentsElem.onmouseleave = function() {
        if (!navbar.classList.contains('scrolling')) {
          navbar.classList.add('scrolling');
        }
      }

      if (false === tocFolding) {

      } else {
        tableOfContentsElem.querySelectorAll('ul') ?
          tableOfContentsElem.querySelectorAll('ul').forEach(function (rootUl) {
            rootUl.querySelectorAll('li').forEach(function (liElem) {
              liElem.querySelectorAll('ul').forEach(function (ulElem) {
                ulElem.style.display = 'none';
              });
            });
          }) : null;
      }

      if (tableOfContentsElem) {
        if (tableOfContentsElem.querySelectorAll('a').length > 0) {
          tableOfContentsElem.querySelectorAll('a').forEach(function (elem) {
            elem.addEventListener('click', function () {
              var id = elem.getAttribute('id');

              if (!navbar.classList.contains('scrolling')) {
                navbar.classList.remove('navbar--show');
                navbar.classList.remove('navbar--hide');
                navbar.classList.add('navbar--hide');
              }
              
              document.querySelector('.toc').querySelectorAll('a').forEach(function (elem) {
                elem.classList.remove('active');
              });
              elem.classList.add('active');

              var curElem = tableOfContentsElem.querySelector('[href="#' + id + '"]');
              if (curElem && curElem.nextElementSibling) {
                curElem.nextElementSibling.style.display = 'block';
              }
              if (curElem) {
                getParents(curElem, 'ul') ?
                  getParents(curElem, 'ul').forEach(function (elem) {
                    elem.style.display = 'block';
                  }) : null;
              }
            });
          });
        } else {
          if (tocFlexbox) {
            tocFlexbox.setAttribute('data-position', '');
            if (!tocFlexbox.classList.contains('hide')) {
              tocFlexbox.classList.add('hide');
            }
          }
          if (tocFlexboxOuter) {
            tocFlexboxOuter.setAttribute('data-position', '');
            if (!tocFlexboxOuter.classList.contains('hide')) {
              tocFlexboxOuter.classList.add('hide');
            }
          }
        }
      }

      
      var toggleTocElem = document.getElementById("toggle-toc");
      var visibleTocElem = document.getElementById('visible-toc');
      var tocElem = document.querySelector('.toc');
      var mainElem = document.querySelector('main');
      var sideElem = document.querySelector('side');
      var tocFlexboxElem = document.querySelector('.toc__flexbox');

      toggleTocElem ? 
      toggleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'fixed');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main-main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
          if (tocFlexboxElem) {
            tocFlexboxElem.setAttribute('data-position', 'absolute');
          }

          if (mainElem) {
            mainElem.classList.remove('main-main');
            mainElem.classList.remove('main');
            mainElem.classList.add('main');
          }
          if (sideElem) {
            sideElem.classList.remove('main-side');
          }
        }
      }) : null;

      visibleTocElem ?
      visibleTocElem.addEventListener('change', function(e) {
        if (e.target.checked) {
          if (tocElem) {
            fadeIn(tocElem, 200);
          }
        } else {
          if (tocElem) {
            fadeOut(tocElem, 200);
          }
        }
      }) : null;
    }
    
    
    
    
    
    var topOffset = 120;
    var botOffset = 70;
    var handleWindowResize = function () {
      if (tocElem) {
        tocElem.style.maxHeight = (window.innerHeight - topOffset - botOffset) + 'px';
      }
    }
    var throttledWindowResize = throttle(handleWindowResize, 300);
    throttledWindowResize()

    
    window.addEventListener('resize', throttledWindowResize);
    



    
    var text, clip = new ClipboardJS('.anchor');
    var headers = singleContentsElem.querySelectorAll("h1, h2, h3, h4");

    
    var languagedir = JSON.parse("\"ltr\"");

    headers ? 
    headers.forEach(function (elem) {
      var size = parseInt(elem.tagName.substr(1), 10) * 2;
      var url = encodeURI(document.location.origin + document.location.pathname);
      var link = url + "#" + elem.getAttribute('id');
      var newElemOuter = document.createElement('span');
      newElemOuter.classList.add('anchor');
      newElemOuter.classList.add('hide');
      newElemOuter.setAttribute('data-clipboard-text', decodeURI(link));
      newElemOuter.style.position = 'relative';

      var newElemInner = document.createElement('span');
      newElemInner.style.position = 'absolute';
      newElemInner.style.top = '50%';
      newElemInner.style.left = '0.75rem';
      newElemInner.style.transform = 'translateY(-50%)';
      newElemInner.innerHTML = `
<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="${32 - size}px" height="${32 - size}px"><path d="M 5.5625 0 C 4.136719 0 2.707031 0.542969 1.625 1.625 C -0.539063 3.789063 -0.539063 7.335938 1.625 9.5 L 5.28125 13.15625 C 5.667969 13.554688 6.304688 13.558594 6.703125 13.171875 C 7.101563 12.785156 7.105469 12.148438 6.71875 11.75 L 3.03125 8.0625 C 1.632813 6.664063 1.632813 4.429688 3.03125 3.03125 C 4.429688 1.632813 6.664063 1.632813 8.0625 3.03125 L 12.96875 7.9375 C 14.367188 9.335938 14.367188 11.570313 12.96875 12.96875 C 12.804688 13.132813 12.621094 13.25 12.4375 13.375 C 11.980469 13.6875 11.859375 14.308594 12.171875 14.765625 C 12.484375 15.222656 13.105469 15.34375 13.5625 15.03125 C 13.847656 14.835938 14.125 14.625 14.375 14.375 C 16.539063 12.210938 16.539063 8.664063 14.375 6.5 L 9.5 1.625 C 8.417969 0.542969 6.988281 0 5.5625 0 Z M 10.78125 8.875 C 10.738281 8.882813 10.695313 8.894531 10.65625 8.90625 C 10.507813 8.9375 10.371094 9 10.25 9.09375 C 10.039063 9.253906 9.820313 9.429688 9.625 9.625 C 7.460938 11.789063 7.460938 15.335938 9.625 17.5 L 14.5 22.375 C 16.664063 24.539063 20.210938 24.539063 22.375 22.375 C 24.539063 20.210938 24.539063 16.664063 22.375 14.5 L 18.71875 10.875 C 18.476563 10.578125 18.089844 10.441406 17.714844 10.527344 C 17.34375 10.613281 17.050781 10.90625 16.964844 11.277344 C 16.878906 11.652344 17.015625 12.039063 17.3125 12.28125 L 20.96875 15.9375 C 22.367188 17.335938 22.367188 19.570313 20.96875 20.96875 C 19.570313 22.367188 17.335938 22.367188 15.9375 20.96875 L 11.03125 16.0625 C 9.632813 14.664063 9.632813 12.429688 11.03125 11.03125 C 11.152344 10.90625 11.300781 10.820313 11.4375 10.71875 C 11.839844 10.472656 12.015625 9.976563 11.855469 9.53125 C 11.699219 9.085938 11.25 8.8125 10.78125 8.875 Z"/></svg>`;

      if (languagedir === "rtl") {
        newElemInner.style.left = '-2rem';
      } else {
        newElemInner.style.right = '-2rem';
      }

      newElemOuter.append(newElemInner);
      elem.append(newElemOuter);

      elem.addEventListener('mouseenter', function() {
        this.querySelector('.anchor').classList.remove('hide');
      });
      elem.addEventListener('mouseleave', function () {
        this.querySelector('.anchor').classList.add('hide');
      });
    }) : null;

    document.querySelectorAll('.anchor').forEach(function(elem) {
      elem.addEventListener('mouseleave', function() {
        elem.setAttribute('aria-label', null);
        elem.classList.remove('tooltipped');
        elem.classList.remove('tooltipped-s');
        elem.classList.remove('tooltipped-w');
      });
    });

    clip.on('success', function (e) {
      e.clearSelection();
      e.trigger.setAttribute('aria-label', 'Link copied to clipboard!');
      e.trigger.classList.add('tooltipped');
      e.trigger.classList.add('tooltipped-s');
    });
    // =================================================================



    
    
    var lib = JSON.parse("null");

    if (lib && lib.includes('mermaid')) {
      
      var themeVariant = localStorage.getItem('theme') || JSON.parse("\"dark\"");

      if (themeVariant === "dark" || themeVariant === "hacker") {
        mermaid.initialize({ theme: 'dark' });
      } else {
        mermaid.initialize({ theme: 'default' });
      }
      
      var mermaids = [];
      [].push.apply(mermaids, document.getElementsByClassName('language-mermaid'));
      mermaids.forEach(function(elem) {
        var elemParentNode = elem.parentNode;

        if (elemParentNode !== document.body) {
          elemParentNode.parentNode.insertBefore(elem, elemParentNode);
          elemParentNode.parentNode.removeChild(elemParentNode);
        }

        var newElemWrapper = document.createElement('div');
        newElemWrapper.classList.add('mermaid');
        newElemWrapper.style.padding = '34px 4px 6px';
        newElemWrapper.innerHTML = elem.innerHTML;
        elem.replaceWith(newElemWrapper);
      });
    }
    

    

    
    if (lib && lib.includes('katex')) {
      var mathElements = document.getElementsByClassName('math');
      var options = {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "$", right: "$", display: false },
          { left: "\\(", right: "\\)", display: false }
        ],
      };

      renderMathInElement(document.querySelector('.single__contents'), options);
    }
    



    
    if (lib && lib.includes('flowchartjs')) {
      
      var options = JSON.parse("{\"arrow-end\":\"block\",\"element-color\":\"black\",\"fill\":\"white\",\"flowstate\":{\"approved\":{\"fill\":\"#58C4A3\",\"font-size\":12,\"no-text\":\"n/a\",\"yes-text\":\"APPROVED\"},\"current\":{\"fill\":\"yellow\",\"font-color\":\"red\",\"font-weight\":\"bold\"},\"future\":{\"fill\":\"#FFFF99\"},\"invalid\":{\"fill\":\"#444444\"},\"past\":{\"fill\":\"#CCCCCC\",\"font-size\":12},\"rejected\":{\"fill\":\"#C45879\",\"font-size\":12,\"no-text\":\"REJECTED\",\"yes-text\":\"n/a\"},\"request\":{\"fill\":\"blue\"}},\"font-color\":\"black\",\"font-size\":14,\"line-color\":\"black\",\"line-length\":50,\"line-width\":3,\"no-text\":\"no\",\"scale\":1,\"symbols\":{\"end\":{\"class\":\"end-element\"},\"start\":{\"element-color\":\"green\",\"fill\":\"yellow\",\"font-color\":\"red\"}},\"text-margin\":10,\"x\":0,\"y\":0,\"yes-text\":\"yes\"}");
      var jsonContent = null;

      var flowchartPrefix = "language-flowchart";
      var index = 0;
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + flowchartPrefix + "]"), function(x){
          x.style.display = 'none'
          x.parentNode.style.backgroundColor = "transparent"
          jsonContent = x.innerText;

          var node0 = document.createElement('div');
          node0.id = 'flowchart' + index;
          x.parentNode.insertBefore(node0, x);

          var diagram = flowchart.parse(jsonContent);
          diagram.drawSVG("flowchart"+index, options);

          index +=1;
      });      
    }
    

    

    
    document.querySelectorAll("mjx-container").forEach(function (x) {
      x.parentElement.classList += 'has-jax'
    });
    



    
    if (lib && lib.includes('msc')) {
      
      var options = JSON.parse("{\"theme\":\"hand\"}");
      var jsonContent = null;

      var index = 0;
      var chartPrefix = "language-msc";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        node0.id = 'msc' + index;
        x.parentNode.insertBefore(node0, x);
        var diagram = Diagram.parse(jsonContent);
        diagram.drawSVG("msc" + index, options);
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('chart')) {
      var borderColor = "#666";
      var bgColor = "#ddd";
      var borderWidth = 2;

      Chart.defaults.global.elements.rectangle.borderWidth = borderWidth;
      Chart.defaults.global.elements.rectangle.borderColor = borderColor;
      Chart.defaults.global.elements.rectangle.backgroundColor = bgColor;

      Chart.defaults.global.elements.line.borderWidth = borderWidth;
      Chart.defaults.global.elements.line.borderColor = borderColor;
      Chart.defaults.global.elements.line.backgroundColor = bgColor;

      Chart.defaults.global.elements.point.borderWidth = borderWidth;
      Chart.defaults.global.elements.point.borderColor = borderColor;
      Chart.defaults.global.elements.point.backgroundColor = bgColor;

      var chartPrefix = "language-chart";
      var index = 0;
      var jsonContent = null;

      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + chartPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('canvas');
        var source = null;
        node0.height = 200;
        node0.style.height = 200;
        node0.id = 'myChart' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        var ctx = document.getElementById('myChart' + index).getContext('2d');
        var myChart = new Chart(ctx, source);
        index += 1;
      });            
    }
    



    
    if (lib && lib.includes('wavedrom')) {
      var wavePrefix = "language-wave";
      var index = 0;
      var jsonContent = null;
      
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + wavePrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        jsonContent = x.innerText;
        var node0 = document.createElement('div');
        var source = null;
        node0.id = 'WaveDrom_Display_' + index;
        source = JSON.parse(jsonContent);
        x.parentNode.insertBefore(node0, x);
        WaveDrom.RenderWaveForm(index, source, "WaveDrom_Display_");
        index += 1;
      });
    }
    



    
    if (lib && lib.includes('viz')) {
      var vizPrefix = "language-viz-";
      Array.prototype.forEach.call(document.querySelectorAll("[class^=" + vizPrefix + "]"), function (x) {
        x.style.display = 'none'
        x.parentNode.style.backgroundColor = "transparent"
        var engine;
        x.getAttribute("class").split(" ").forEach(function (cls) {
          if (cls.startsWith(vizPrefix)) {
            engine = cls.substr(vizPrefix.length);
          }
        });
        var viz = new Viz();
        viz.renderSVGElement(x.innerText, { engine: engine })
          .then(function (element) {
            element.style.width = "100%";
            x.parentNode.insertBefore(element, x);
          })
      });
    }
    
    
  }
</script>


            
            <footer class="footer">
    
<div class="dropdown">
  <button class="dropdown-trigger" aria-label="Select Language Button">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path fill="currentColor" d="M12.65 15.67c.14-.36.05-.77-.23-1.05l-2.09-2.06.03-.03c1.74-1.94 2.98-4.17 3.71-6.53h1.94c.54 0 .99-.45.99-.99v-.02c0-.54-.45-.99-.99-.99H10V3c0-.55-.45-1-1-1s-1 .45-1 1v1H1.99c-.54 0-.99.45-.99.99 0 .55.45.99.99.99h10.18C11.5 7.92 10.44 9.75 9 11.35c-.81-.89-1.49-1.86-2.06-2.88-.16-.29-.45-.47-.78-.47-.69 0-1.13.75-.79 1.35.63 1.13 1.4 2.21 2.3 3.21L3.3 16.87c-.4.39-.4 1.03 0 1.42.39.39 1.02.39 1.42 0L9 14l2.02 2.02c.51.51 1.38.32 1.63-.35zM17.5 10c-.6 0-1.14.37-1.35.94l-3.67 9.8c-.24.61.22 1.26.87 1.26.39 0 .74-.24.88-.61l.89-2.39h4.75l.9 2.39c.14.36.49.61.88.61.65 0 1.11-.65.88-1.26l-3.67-9.8c-.22-.57-.76-.94-1.36-.94zm-1.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>
  </button>
  <div class="dropdown-content">
    
    
    
  </div>
</div>

    
    
<div id="gtt">
  <div class="gtt">
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M8.12 14.71L12 10.83l3.88 3.88c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L12.7 8.71c-.39-.39-1.02-.39-1.41 0L6.7 13.3c-.39.39-.39 1.02 0 1.41.39.38 1.03.39 1.42 0z"/></svg>
  </div>
</div>

    <hr />

    <div class="basicflex flexwrap">
        
            
        
            
        
    </div>

    <div class="footer__poweredby">
        
                
            <p class="caption">
                
                    ©2021, All Rights Reserved
                
            </p>
        

        
            <p class="caption">Powered by <a href="https://gohugo.io/" target="_blank" rel="noreferrer">Hugo</a> and the <a href="https://github.com/zzossig/hugo-theme-zzo" target="_blank" rel="noreferrer">Zzo theme</a></p>
        
        
    </div> 
</footer>
        </div>
        





<div class="wrapper__right hide" data-pad="true" dir="ltr">
  <script>document.querySelector('.wrapper__right').classList.remove('hide')</script>
  
    
      
        <div class="toc__flexbox--outer" data-position="fixed" data-dir="ltr" data-ani="true">
          <h6 class="toc__title toc__title--outer" data-ani="true">What&#39;s on this Page</h6>
          
          <label class="switch" data-ani="true">
            <input id="visible-toc" aria-label="Visible TOC" type="checkbox" checked>
            <span class="slider round"></span>
          </label>
          
        </div>
        <div class="toc toc__outer " data-dir="ltr" data-folding="true" data-ani="true">
          <nav id="TableOfContents">
  <ul>
    <li><a href="#区域尺度城市土地遥感监测关键技术研究">区域尺度城市土地遥感监测关键技术研究</a>
      <ul>
        <li><a href="#摘要">摘要</a></li>
      </ul>
    </li>
    <li><a href="#轨迹数据挖掘关键技术研究">轨迹数据挖掘关键技术研究</a>
      <ul>
        <li><a href="#摘要-1">摘要</a></li>
        <li><a href="#绪论">绪论</a>
          <ul>
            <li><a href="#研究工作的背景与意义">研究工作的背景与意义</a></li>
          </ul>
        </li>
        <li><a href="#轨迹数据挖掘相关理论基础">轨迹数据挖掘相关理论基础</a>
          <ul>
            <li><a href="#轨迹数据语义研究相关理论">轨迹数据语义研究相关理论</a>
              <ul>
                <li><a href="#轨迹数据中的语义信息按语义层次">轨迹数据中的语义信息（按语义层次）</a></li>
                <li><a href="#当前轨迹数据语义研究">当前轨迹数据语义研究</a></li>
              </ul>
            </li>
            <li><a href="#轨迹表征研究相关理论">轨迹表征研究相关理论</a></li>
            <li><a href="#位置预测研究相关理论">位置预测研究相关理论</a></li>
          </ul>
        </li>
        <li><a href="#第三章-基于图卷积神经网络的位置语义推断">第三章 基于图卷积神经网络的位置语义推断</a>
          <ul>
            <li><a href="#引言">引言</a></li>
            <li><a href="#si-gcn框架">SI-GCN框架</a>
              <ul>
                <li><a href="#三部分">三部分</a></li>
                <li><a href="#位置时空特征提取">位置时空特征提取</a></li>
                <li><a href="#图卷积神经网络推断模型">图卷积神经网络推断模型</a></li>
              </ul>
            </li>
            <li><a href="#实验与分析">实验与分析</a></li>
          </ul>
        </li>
        <li><a href="#第四章-融合时空结构的轨迹数据表征学习">第四章 融合时空结构的轨迹数据表征学习</a>
          <ul>
            <li><a href="#引言-1">引言</a></li>
            <li><a href="#框架概述">框架概述</a></li>
            <li><a href="#轨迹表征学习模型">轨迹表征学习模型</a>
              <ul>
                <li><a href="#轨迹空间信息向量表征">轨迹空间信息向量表征</a></li>
                <li><a href="#时间信息建模">时间信息建模</a></li>
                <li><a href="#基于轨迹表征的异常检测">基于轨迹表征的异常检测</a></li>
              </ul>
            </li>
            <li><a href="#实验与分析-1">实验与分析</a></li>
          </ul>
        </li>
        <li><a href="#第五章-基于偏好社交互动的位置预测算法">第五章 基于偏好社交互动的位置预测算法</a>
          <ul>
            <li><a href="#引言-2">引言</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#基于地理场景的城市功能区建模与分析方法研究">基于地理场景的城市功能区建模与分析方法研究</a>
      <ul>
        <li><a href="#札记">札记</a></li>
        <li><a href="#摘要-2">摘要</a></li>
        <li><a href="#第一章-绪论">第一章 绪论</a>
          <ul>
            <li><a href="#论文研究背景与意义">论文研究背景与意义</a></li>
            <li><a href="#基于地理场景的功能区分析中基本概念">基于地理场景的功能区分析中基本概念</a>
              <ul>
                <li><a href="#城市功能区相关概念及分类体系">城市功能区相关概念及分类体系</a></li>
                <li><a href="#地理场景相关概念">地理场景相关概念</a></li>
              </ul>
            </li>
            <li><a href="#研究现状与存在问题">研究现状与存在问题</a>
              <ul>
                <li><a href="#引言-3">引言</a></li>
                <li><a href="#城市功能区分割提取的研究现状和存在问题">城市功能区分割提取的研究现状和存在问题</a></li>
                <li><a href="#城市功能区特征表达的研究现状和存在问题">城市功能区特征表达的研究现状和存在问题</a></li>
                <li><a href="#城市功能区分类识别的研究现状和存在问题">城市功能区分类识别的研究现状和存在问题</a></li>
              </ul>
            </li>
            <li><a href="#研究目标与内容">研究目标与内容</a></li>
          </ul>
        </li>
        <li><a href="#第二章-多尺度地理场景分割功能区分割提取">第二章 多尺度地理场景分割：功能区分割提取</a>
          <ul>
            <li><a href="#引言-4">引言</a>
              <ul>
                <li><a href="#功能区分割提取的研究背景">功能区分割提取的研究背景</a></li>
                <li><a href="#地理场景-功能区的影像建模方法">地理场景： 功能区的影像建模方法</a></li>
              </ul>
            </li>
            <li><a href="#多尺度地理场景分割">多尺度地理场景分割</a>
              <ul>
                <li><a href="#空间分布特征">空间分布特征</a></li>
                <li><a href="#地理场景分割">地理场景分割</a></li>
                <li><a href="#多尺度分割">多尺度分割</a></li>
                <li><a href="#分割结果评价">分割结果评价</a></li>
              </ul>
            </li>
            <li><a href="#实验分析">实验分析</a>
              <ul>
                <li><a href="#实验数据">实验数据</a></li>
                <li><a href="#多尺度功能区分割提取结果">多尺度功能区分割提取结果</a></li>
                <li><a href="#空间模式特征在功能区分割中重要性评价">空间模式特征在功能区分割中重要性评价</a></li>
                <li><a href="#功能区分割提取结果">功能区分割提取结果</a></li>
              </ul>
            </li>
            <li><a href="#讨论">讨论</a>
              <ul>
                <li><a href="#本章方法与传统的功能区分析对比">本章方法与传统的功能区分析对比</a></li>
                <li><a href="#面向地理场景分析与面向对象分析对比">面向地理场景分析与面向对象分析对比</a></li>
              </ul>
            </li>
            <li><a href="#本章小结">本章小结</a></li>
          </ul>
        </li>
        <li><a href="#第三章-自适应尺度学习功能区分割尺度优化">第三章 自适应尺度学习：功能区分割尺度优化</a>
          <ul>
            <li><a href="#引言-5">引言</a></li>
            <li><a href="#自适应尺度功能区分割">自适应尺度功能区分割</a>
              <ul>
                <li><a href="#自适应分割尺度学习">自适应分割尺度学习</a></li>
                <li><a href="#自适应尺度约束下功能区分割">自适应尺度约束下功能区分割</a></li>
              </ul>
            </li>
            <li><a href="#实验分析-1">实验分析</a>
              <ul>
                <li><a href="#自适应分割尺度学习结果">自适应分割尺度学习结果</a></li>
                <li><a href="#自适应尺度分割结果">自适应尺度分割结果</a></li>
              </ul>
            </li>
            <li><a href="#讨论-1">讨论</a></li>
            <li><a href="#本章小结conclusion模板">本章小结（Conclusion模板）</a></li>
          </ul>
        </li>
        <li><a href="#第四章-空间语义共生概率模型功能区空间格局特征表达">第四章 空间语义共生概率模型：功能区空间格局特征表达</a>
          <ul>
            <li><a href="#引言-6">引言</a></li>
            <li><a href="#地理对象的空间语义共生分析">地理对象的空间语义共生分析</a></li>
            <li><a href="#实验分析-2">实验分析</a>
              <ul>
                <li><a href="#第一部分使用公共数据集将本章所提出的空间语义特征与其它场景特征进行对比">第一部分：使用公共数据集，将本章所提出的空间语义特征与其它场景特征进行对比</a></li>
                <li><a href="#第二部分北京地区功能区表达与识别">第二部分：北京地区功能区表达与识别</a></li>
              </ul>
            </li>
            <li><a href="#讨论-2">讨论</a></li>
            <li><a href="#本章小结-1">本章小结</a></li>
          </ul>
        </li>
        <li><a href="#第五章-层次语义认知模型-功能区多源特征层次依赖性表达">第五章 层次语义认知模型： 功能区多源特征层次依赖性表达</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </div>
      
    
  
</div>

    </div>


    <a id="search-btn" style="display: inline-block;" href="javascript:void(0);">
        <span class="icon-search">捜</span>
    </a>
    
    <div id="fastSearch">
        <input id="searchInput" tabindex="0">
        <ul id="searchResults">
        </ul>
    </div>

    
    <script defer src="/js/fuse.min.227dc237b65445027834bc62afbd220f4bdf89bc50cc452f2bf539114167854f.js"></script>

    
    <script defer src="/js/fastsearch.23edf7ca4eb81e21b62a5edf2e438f1f95d5974a2965d58284961957b60638b5.js"></script>

    

</body>

</html>